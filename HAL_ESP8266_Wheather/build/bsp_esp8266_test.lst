ARM GAS  /tmp/ccRW1hdZ.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"bsp_esp8266_test.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.rodata.analytical_data.str1.4,"aMS",%progbits,1
  18              		.align	2
  19              	.LC0:
  20 0000 6E616D65 		.ascii	"name\000"
  20      00
  21 0005 000000   		.align	2
  22              	.LC1:
  23 0008 255B5E22 		.ascii	"%[^\"]\000"
  23      5D00
  24 000e 0000     		.align	2
  25              	.LC2:
  26 0010 63697479 		.ascii	"city: %s\012\000"
  26      3A202573 
  26      0A00
  27 001a 0000     		.align	2
  28              	.LC3:
  29 001c 74657874 		.ascii	"text\000"
  29      00
  30 0021 000000   		.align	2
  31              	.LC4:
  32 0024 74656D70 		.ascii	"temp: %s\012\000"
  32      3A202573 
  32      0A00
  33 002e 0000     		.align	2
  34              	.LC5:
  35 0030 74656D70 		.ascii	"temperature\000"
  35      65726174 
  35      75726500 
  36              		.align	2
  37              	.LC6:
  38 003c 6C617374 		.ascii	"last_update\000"
  38      5F757064 
  38      61746500 
  39              		.align	2
  40              	.LC7:
  41 0048 255B5E54 		.ascii	"%[^T]\000"
  41      5D00
  42 004e 0000     		.align	2
  43              	.LC8:
  44 0050 74656D70 		.ascii	"temp: %s\012\012\012\000"
  44      3A202573 
ARM GAS  /tmp/ccRW1hdZ.s 			page 2


  44      0A0A0A00 
  45              		.section	.text.analytical_data,"ax",%progbits
  46              		.align	1
  47              		.global	analytical_data
  48              		.arch armv7e-m
  49              		.syntax unified
  50              		.thumb
  51              		.thumb_func
  52              		.fpu fpv4-sp-d16
  54              	analytical_data:
  55              	.LFB739:
  56              		.file 1 "./Hardware/ESP8266/bsp_esp8266_test.c"
   1:./Hardware/ESP8266/bsp_esp8266_test.c **** #include "bsp_esp8266_test.h"
   2:./Hardware/ESP8266/bsp_esp8266_test.c **** 
   3:./Hardware/ESP8266/bsp_esp8266_test.c **** volatile uint8_t ucTcpClosedFlag = 0;
   4:./Hardware/ESP8266/bsp_esp8266_test.c **** 
   5:./Hardware/ESP8266/bsp_esp8266_test.c **** //Ëß£ÊûêÂêéÁöÑÊï∞ÊçÆÔºåÂêéÁª≠ÂºÄÂèëÊó∂ÂèØ‰ª•Áõ¥Êé•Áî®Ëøô‰∫õÂÄº
   6:./Hardware/ESP8266/bsp_esp8266_test.c **** typedef struct Date
   7:./Hardware/ESP8266/bsp_esp8266_test.c **** {
   8:./Hardware/ESP8266/bsp_esp8266_test.c **** 	char text_city[10];   //ÂüéÂ∏Ç
   9:./Hardware/ESP8266/bsp_esp8266_test.c **** 	char text_weather[10];    //Â§©Ê∞î
  10:./Hardware/ESP8266/bsp_esp8266_test.c **** 	char text_temp[10];    //Ê∏©Â∫¶
  11:./Hardware/ESP8266/bsp_esp8266_test.c **** 	char text_date[30];   //Êó•Êúü
  12:./Hardware/ESP8266/bsp_esp8266_test.c **** }WEATHER_InitTypeDef;
  13:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  14:./Hardware/ESP8266/bsp_esp8266_test.c **** /******************************************************************
  15:./Hardware/ESP8266/bsp_esp8266_test.c **** *    !!!!! Ê≥®ÊÑèÔºöESP8266 Êé•Êî∂Âà∞ÁöÑÊï∞ÊçÆÂ≠òÂÇ®Âú®Êï∞ÁªÑ strEsp8266_Fram_Record .Data_RX_BUF ‰
  16:./Hardware/ESP8266/bsp_esp8266_test.c **** *               ÈúÄË¶ÅËß£ÊûêÊï∞ÊçÆÔºåÂπ∂ÂÅöÂá∫ÂØπÂ∫îÁöÑÊìç‰Ωú
  17:./Hardware/ESP8266/bsp_esp8266_test.c **** ******************************************************************/
  18:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  19:./Hardware/ESP8266/bsp_esp8266_test.c **** /**
  20:./Hardware/ESP8266/bsp_esp8266_test.c ****  * @brief  analytical_data
  21:./Hardware/ESP8266/bsp_esp8266_test.c ****  * @param  null
  22:./Hardware/ESP8266/bsp_esp8266_test.c ****  * @return null
  23:./Hardware/ESP8266/bsp_esp8266_test.c ****  * @note   Ëß£ÊûêÂøÉÁü•Â§©Ê∞îÂèëÈÄÅÁöÑ‰ø°ÊÅØ
  24:./Hardware/ESP8266/bsp_esp8266_test.c ****  *         ËøôÊòØÊé•Êî∂Âà∞ÁöÑÊ∂àÊÅØÔºö{"results":[{"location":{"id":"WW0V9QP93VS8","name":"ÈÉëÂ∑û",
  25:./Hardware/ESP8266/bsp_esp8266_test.c ****  *         Ëß£ÊûêÊï∞ÊçÆÂèØ‰ª•Êü•ÁúãËøôÁØáÊñáÁ´†: https://blog.csdn.net/m0_47329175/article/details/
  26:./Hardware/ESP8266/bsp_esp8266_test.c ****  */
  27:./Hardware/ESP8266/bsp_esp8266_test.c **** void analytical_data(void) {
  57              		.loc 1 27 28 view -0
  58              		.cfi_startproc
  59              		@ args = 0, pretend = 0, frame = 64
  60              		@ frame_needed = 0, uses_anonymous_args = 0
  61 0000 70B5     		push	{r4, r5, r6, lr}
  62              	.LCFI0:
  63              		.cfi_def_cfa_offset 16
  64              		.cfi_offset 4, -16
  65              		.cfi_offset 5, -12
  66              		.cfi_offset 6, -8
  67              		.cfi_offset 14, -4
  68 0002 90B0     		sub	sp, sp, #64
  69              	.LCFI1:
  70              		.cfi_def_cfa_offset 80
  28:./Hardware/ESP8266/bsp_esp8266_test.c **** 	WEATHER_InitTypeDef WEATHER_InitStruct;
  71              		.loc 1 28 2 view .LVU1
  29:./Hardware/ESP8266/bsp_esp8266_test.c **** 	char *str;
  72              		.loc 1 29 2 view .LVU2
ARM GAS  /tmp/ccRW1hdZ.s 			page 3


  30:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  31:./Hardware/ESP8266/bsp_esp8266_test.c **** 	//ÂæóÂà∞ÂüéÂ∏Ç
  32:./Hardware/ESP8266/bsp_esp8266_test.c **** 	str = strstr(strEsp8266_Fram_Record.Data_RX_BUF,"name");
  73              		.loc 1 32 2 view .LVU3
  74              		.loc 1 32 8 is_stmt 0 view .LVU4
  75 0004 1E4C     		ldr	r4, .L3
  76 0006 1F49     		ldr	r1, .L3+4
  77 0008 2046     		mov	r0, r4
  78 000a FFF7FEFF 		bl	strstr
  79              	.LVL0:
  33:./Hardware/ESP8266/bsp_esp8266_test.c **** 	str += 7;
  80              		.loc 1 33 2 is_stmt 1 view .LVU5
  34:./Hardware/ESP8266/bsp_esp8266_test.c **** 	sscanf(str,"%[^\"]",WEATHER_InitStruct.text_city);
  81              		.loc 1 34 2 view .LVU6
  82 000e 1E4D     		ldr	r5, .L3+8
  83 0010 01AA     		add	r2, sp, #4
  84 0012 2946     		mov	r1, r5
  85 0014 0730     		adds	r0, r0, #7
  86              	.LVL1:
  87              		.loc 1 34 2 is_stmt 0 view .LVU7
  88 0016 FFF7FEFF 		bl	sscanf
  89              	.LVL2:
  35:./Hardware/ESP8266/bsp_esp8266_test.c **** 	printf("city: %s\n",WEATHER_InitStruct.text_city);
  90              		.loc 1 35 2 is_stmt 1 view .LVU8
  91 001a 01A9     		add	r1, sp, #4
  92 001c 1B48     		ldr	r0, .L3+12
  93 001e FFF7FEFF 		bl	printf
  94              	.LVL3:
  36:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  37:./Hardware/ESP8266/bsp_esp8266_test.c **** 	//ÂæóÂà∞Â§©Ê∞î
  38:./Hardware/ESP8266/bsp_esp8266_test.c **** 	str = strstr(strEsp8266_Fram_Record.Data_RX_BUF,"text");
  95              		.loc 1 38 2 view .LVU9
  96              		.loc 1 38 8 is_stmt 0 view .LVU10
  97 0022 1B49     		ldr	r1, .L3+16
  98 0024 2046     		mov	r0, r4
  99 0026 FFF7FEFF 		bl	strstr
 100              	.LVL4:
  39:./Hardware/ESP8266/bsp_esp8266_test.c **** 	str += 7;
 101              		.loc 1 39 2 is_stmt 1 view .LVU11
  40:./Hardware/ESP8266/bsp_esp8266_test.c **** 	sscanf(str,"%[^\"]",WEATHER_InitStruct.text_weather);
 102              		.loc 1 40 2 view .LVU12
 103 002a 0DF10E02 		add	r2, sp, #14
 104 002e 2946     		mov	r1, r5
 105 0030 0730     		adds	r0, r0, #7
 106              	.LVL5:
 107              		.loc 1 40 2 is_stmt 0 view .LVU13
 108 0032 FFF7FEFF 		bl	sscanf
 109              	.LVL6:
  41:./Hardware/ESP8266/bsp_esp8266_test.c **** 	printf("temp: %s\n",WEATHER_InitStruct.text_weather);
 110              		.loc 1 41 2 is_stmt 1 view .LVU14
 111 0036 174E     		ldr	r6, .L3+20
 112 0038 0DF10E01 		add	r1, sp, #14
 113 003c 3046     		mov	r0, r6
 114 003e FFF7FEFF 		bl	printf
 115              	.LVL7:
  42:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  43:./Hardware/ESP8266/bsp_esp8266_test.c **** 	//ÂæóÂà∞Ê∏©Â∫¶ 
ARM GAS  /tmp/ccRW1hdZ.s 			page 4


  44:./Hardware/ESP8266/bsp_esp8266_test.c **** 	str = strstr(strEsp8266_Fram_Record.Data_RX_BUF,"temperature");
 116              		.loc 1 44 2 view .LVU15
 117              		.loc 1 44 8 is_stmt 0 view .LVU16
 118 0042 1549     		ldr	r1, .L3+24
 119 0044 2046     		mov	r0, r4
 120 0046 FFF7FEFF 		bl	strstr
 121              	.LVL8:
  45:./Hardware/ESP8266/bsp_esp8266_test.c **** 	str += 14;
 122              		.loc 1 45 2 is_stmt 1 view .LVU17
  46:./Hardware/ESP8266/bsp_esp8266_test.c **** 	sscanf(str,"%[^\"]",WEATHER_InitStruct.text_temp);
 123              		.loc 1 46 2 view .LVU18
 124 004a 06AA     		add	r2, sp, #24
 125 004c 2946     		mov	r1, r5
 126 004e 0E30     		adds	r0, r0, #14
 127              	.LVL9:
 128              		.loc 1 46 2 is_stmt 0 view .LVU19
 129 0050 FFF7FEFF 		bl	sscanf
 130              	.LVL10:
  47:./Hardware/ESP8266/bsp_esp8266_test.c **** 	printf("temp: %s\n",WEATHER_InitStruct.text_temp);
 131              		.loc 1 47 2 is_stmt 1 view .LVU20
 132 0054 06A9     		add	r1, sp, #24
 133 0056 3046     		mov	r0, r6
 134 0058 FFF7FEFF 		bl	printf
 135              	.LVL11:
  48:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  49:./Hardware/ESP8266/bsp_esp8266_test.c **** 	//ÂæóÂà∞Êó•Êúü 
  50:./Hardware/ESP8266/bsp_esp8266_test.c **** 	str = strstr(strEsp8266_Fram_Record.Data_RX_BUF,"last_update");
 136              		.loc 1 50 2 view .LVU21
 137              		.loc 1 50 8 is_stmt 0 view .LVU22
 138 005c 0F49     		ldr	r1, .L3+28
 139 005e 2046     		mov	r0, r4
 140 0060 FFF7FEFF 		bl	strstr
 141              	.LVL12:
  51:./Hardware/ESP8266/bsp_esp8266_test.c **** 	str += 14;
 142              		.loc 1 51 2 is_stmt 1 view .LVU23
  52:./Hardware/ESP8266/bsp_esp8266_test.c **** 	sscanf(str,"%[^T]",WEATHER_InitStruct.text_date);
 143              		.loc 1 52 2 view .LVU24
 144 0064 0DF12202 		add	r2, sp, #34
 145 0068 0D49     		ldr	r1, .L3+32
 146 006a 0E30     		adds	r0, r0, #14
 147              	.LVL13:
 148              		.loc 1 52 2 is_stmt 0 view .LVU25
 149 006c FFF7FEFF 		bl	sscanf
 150              	.LVL14:
  53:./Hardware/ESP8266/bsp_esp8266_test.c **** 	printf("temp: %s\n\n\n",WEATHER_InitStruct.text_date);
 151              		.loc 1 53 2 is_stmt 1 view .LVU26
 152 0070 0DF12201 		add	r1, sp, #34
 153 0074 0B48     		ldr	r0, .L3+36
 154 0076 FFF7FEFF 		bl	printf
 155              	.LVL15:
  54:./Hardware/ESP8266/bsp_esp8266_test.c **** }
 156              		.loc 1 54 1 is_stmt 0 view .LVU27
 157 007a 10B0     		add	sp, sp, #64
 158              	.LCFI2:
 159              		.cfi_def_cfa_offset 16
 160              		@ sp needed
 161 007c 70BD     		pop	{r4, r5, r6, pc}
ARM GAS  /tmp/ccRW1hdZ.s 			page 5


 162              	.L4:
 163 007e 00BF     		.align	2
 164              	.L3:
 165 0080 00000000 		.word	strEsp8266_Fram_Record
 166 0084 00000000 		.word	.LC0
 167 0088 08000000 		.word	.LC1
 168 008c 10000000 		.word	.LC2
 169 0090 1C000000 		.word	.LC3
 170 0094 24000000 		.word	.LC4
 171 0098 30000000 		.word	.LC5
 172 009c 3C000000 		.word	.LC6
 173 00a0 48000000 		.word	.LC7
 174 00a4 50000000 		.word	.LC8
 175              		.cfi_endproc
 176              	.LFE739:
 178              		.section	.rodata.ESP8266_StaTcpClient_Unvarnish_ConfigTest.str1.4,"aMS",%progbits,1
 179              		.align	2
 180              	.LC9:
 181 0000 0D0AE6AD 		.ascii	"\015\012\346\255\243\345\234\250\351\205\215\347\275"
 181      A3E59CA8 
 181      E9858DE7 
 181      BD
 182 000d AE204553 		.ascii	"\256 ESP8266 ......\015\000"
 182      50383236 
 182      36202E2E 
 182      2E2E2E2E 
 182      0D00
 183 001f 00       		.align	2
 184              	.LC10:
 185 0020 0D0AE4BD 		.ascii	"\015\012\344\275\277\350\203\275ESP8266 ......\015\000"
 185      BFE883BD 
 185      45535038 
 185      32363620 
 185      2E2E2E2E 
 186              		.align	2
 187              	.LC11:
 188 0038 0D0AE6AD 		.ascii	"\015\012\346\255\243\345\234\250\351\205\215\347\275"
 188      A3E59CA8 
 188      E9858DE7 
 188      BD
 189 0045 AEE5B7A5 		.ascii	"\256\345\267\245\344\275\234\346\250\241\345\274\217"
 189      E4BD9CE6 
 189      A8A1E5BC 
 189      8F
 190 0052 3A205354 		.ascii	": STA ......\015\000"
 190      41202E2E 
 190      2E2E2E2E 
 190      0D00
 191              		.align	2
 192              	.LC12:
 193 0060 0D0AE6AD 		.ascii	"\015\012\346\255\243\345\234\250\350\277\236\346\216"
 193      A3E59CA8 
 193      E8BF9EE6 
 193      8E
 194 006d A5205769 		.ascii	"\245 WiFi ......\015\000"
 194      4669202E 
 194      2E2E2E2E 
ARM GAS  /tmp/ccRW1hdZ.s 			page 6


 194      2E0D00
 195              		.align	2
 196              	.LC13:
 197 007c 68313233 		.ascii	"h123456.\000"
 197      3435362E 
 197      00
 198 0085 000000   		.align	2
 199              	.LC14:
 200 0088 5265646D 		.ascii	"Redmi K40\000"
 200      69204B34 
 200      3000
 201 0092 0000     		.align	2
 202              	.LC15:
 203 0094 0D0AE7A6 		.ascii	"\015\012\347\246\201\346\255\242\345\244\232\350\277"
 203      81E6ADA2 
 203      E5A49AE8 
 203      BF
 204 00a1 9EE68EA5 		.ascii	"\236\346\216\245 ......\015\000"
 204      202E2E2E 
 204      2E2E2E0D 
 204      00
 205 00ae 0000     		.align	2
 206              	.LC16:
 207 00b0 0D0AE6AD 		.ascii	"\015\012\346\255\243\345\234\250\350\277\236\346\216"
 207      A3E59CA8 
 207      E8BF9EE6 
 207      8E
 208 00bd A5E69C8D 		.ascii	"\245\346\234\215\345\212\241\345\231\250 ......\015"
 208      E58AA1E5 
 208      99A8202E 
 208      2E2E2E2E 
 208      2E0D
 209 00cf 00       		.ascii	"\000"
 210              		.align	2
 211              	.LC17:
 212 00d0 383000   		.ascii	"80\000"
 213 00d3 00       		.align	2
 214              	.LC18:
 215 00d4 6170692E 		.ascii	"api.seniverse.com\000"
 215      73656E69 
 215      76657273 
 215      652E636F 
 215      6D00
 216 00e6 0000     		.align	2
 217              	.LC19:
 218 00e8 0D0AE8BF 		.ascii	"\015\012\350\277\233\345\205\245\351\200\217\344\274"
 218      9BE585A5 
 218      E9808FE4 
 218      BC
 219 00f5 A0E58F91 		.ascii	"\240\345\217\221\351\200\201\346\250\241\345\274\217"
 219      E98081E6 
 219      A8A1E5BC 
 219      8F
 220 0102 202E2E2E 		.ascii	" ......\015\000"
 220      2E2E2E0D 
 220      00
 221 010b 00       		.align	2
ARM GAS  /tmp/ccRW1hdZ.s 			page 7


 222              	.LC20:
 223 010c 0D0AE985 		.ascii	"\015\012\351\205\215\347\275\256 ESP8266 \345\256\214"
 223      8DE7BDAE 
 223      20455350 
 223      38323636 
 223      20E5AE8C 
 224 0120 E6AF950D 		.ascii	"\346\257\225\015\000"
 224      00
 225 0125 000000   		.align	2
 226              	.LC21:
 227 0128 0D0AE5BC 		.ascii	"\015\012\345\274\200\345\247\213\351\200\217\344\274"
 227      80E5A78B 
 227      E9808FE4 
 227      BC
 228 0135 A02E2E2E 		.ascii	"\240......\015\000"
 228      2E2E2E0D 
 228      00
 229              		.section	.text.ESP8266_StaTcpClient_Unvarnish_ConfigTest,"ax",%progbits
 230              		.align	1
 231              		.global	ESP8266_StaTcpClient_Unvarnish_ConfigTest
 232              		.syntax unified
 233              		.thumb
 234              		.thumb_func
 235              		.fpu fpv4-sp-d16
 237              	ESP8266_StaTcpClient_Unvarnish_ConfigTest:
 238              	.LFB740:
  55:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  56:./Hardware/ESP8266/bsp_esp8266_test.c **** /********************************************ËøûÊé•ÊúçÂä°Âô®***************************************
  57:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  58:./Hardware/ESP8266/bsp_esp8266_test.c **** /**
  59:./Hardware/ESP8266/bsp_esp8266_test.c ****   * @brief  ESP8266 StaTcpClient Unvarnish ÈÖçÁΩÆÊµãËØïÂáΩÊï∞
  60:./Hardware/ESP8266/bsp_esp8266_test.c ****   * @param  Êó†
  61:./Hardware/ESP8266/bsp_esp8266_test.c ****   * @retval Êó†
  62:./Hardware/ESP8266/bsp_esp8266_test.c ****   */
  63:./Hardware/ESP8266/bsp_esp8266_test.c **** void ESP8266_StaTcpClient_Unvarnish_ConfigTest(void)
  64:./Hardware/ESP8266/bsp_esp8266_test.c **** {
 239              		.loc 1 64 1 is_stmt 1 view -0
 240              		.cfi_startproc
 241              		@ args = 0, pretend = 0, frame = 0
 242              		@ frame_needed = 0, uses_anonymous_args = 0
 243 0000 08B5     		push	{r3, lr}
 244              	.LCFI3:
 245              		.cfi_def_cfa_offset 8
 246              		.cfi_offset 3, -8
 247              		.cfi_offset 14, -4
  65:./Hardware/ESP8266/bsp_esp8266_test.c ****   printf( "\r\nÊ≠£Âú®ÈÖçÁΩÆ ESP8266 ......\r\n" );
 248              		.loc 1 65 3 view .LVU29
 249 0002 2048     		ldr	r0, .L13
 250 0004 FFF7FEFF 		bl	puts
 251              	.LVL16:
  66:./Hardware/ESP8266/bsp_esp8266_test.c ****   printf( "\r\n‰ΩøËÉΩESP8266 ......\r\n" );
 252              		.loc 1 66 3 view .LVU30
 253 0008 1F48     		ldr	r0, .L13+4
 254 000a FFF7FEFF 		bl	puts
 255              	.LVL17:
  67:./Hardware/ESP8266/bsp_esp8266_test.c **** 	macESP8266_CH_ENABLE();
 256              		.loc 1 67 2 view .LVU31
ARM GAS  /tmp/ccRW1hdZ.s 			page 8


 257 000e 0122     		movs	r2, #1
 258 0010 2021     		movs	r1, #32
 259 0012 1E48     		ldr	r0, .L13+8
 260 0014 FFF7FEFF 		bl	HAL_GPIO_WritePin
 261              	.LVL18:
  68:./Hardware/ESP8266/bsp_esp8266_test.c **** 	while( ! ESP8266_AT_Test() );
 262              		.loc 1 68 2 view .LVU32
 263              	.L6:
 264              		.loc 1 68 30 discriminator 1 view .LVU33
 265              		.loc 1 68 7 discriminator 1 view .LVU34
 266              		.loc 1 68 11 is_stmt 0 discriminator 1 view .LVU35
 267 0018 FFF7FEFF 		bl	ESP8266_AT_Test
 268              	.LVL19:
 269              		.loc 1 68 7 discriminator 1 view .LVU36
 270 001c 0028     		cmp	r0, #0
 271 001e FBD0     		beq	.L6
  69:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  70:./Hardware/ESP8266/bsp_esp8266_test.c ****   printf( "\r\nÊ≠£Âú®ÈÖçÁΩÆÂ∑•‰ΩúÊ®°Âºè: STA ......\r\n" );
 272              		.loc 1 70 3 is_stmt 1 view .LVU37
 273 0020 1B48     		ldr	r0, .L13+12
 274 0022 FFF7FEFF 		bl	puts
 275              	.LVL20:
  71:./Hardware/ESP8266/bsp_esp8266_test.c **** 	while( ! ESP8266_Net_Mode_Choose ( STA ) );
 276              		.loc 1 71 2 view .LVU38
 277              	.L7:
 278              		.loc 1 71 44 discriminator 1 view .LVU39
 279              		.loc 1 71 7 discriminator 1 view .LVU40
 280              		.loc 1 71 11 is_stmt 0 discriminator 1 view .LVU41
 281 0026 0020     		movs	r0, #0
 282 0028 FFF7FEFF 		bl	ESP8266_Net_Mode_Choose
 283              	.LVL21:
 284              		.loc 1 71 7 discriminator 1 view .LVU42
 285 002c 0028     		cmp	r0, #0
 286 002e FAD0     		beq	.L7
  72:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  73:./Hardware/ESP8266/bsp_esp8266_test.c ****   printf( "\r\nÊ≠£Âú®ËøûÊé• WiFi ......\r\n" );
 287              		.loc 1 73 3 is_stmt 1 view .LVU43
 288 0030 1848     		ldr	r0, .L13+16
 289 0032 FFF7FEFF 		bl	puts
 290              	.LVL22:
  74:./Hardware/ESP8266/bsp_esp8266_test.c ****   while( ! ESP8266_JoinAP ( macUser_ESP8266_ApSsid, macUser_ESP8266_ApPwd ) );	
 291              		.loc 1 74 3 view .LVU44
 292              	.L8:
 293              		.loc 1 74 78 discriminator 1 view .LVU45
 294              		.loc 1 74 8 discriminator 1 view .LVU46
 295              		.loc 1 74 12 is_stmt 0 discriminator 1 view .LVU47
 296 0036 1849     		ldr	r1, .L13+20
 297 0038 1848     		ldr	r0, .L13+24
 298 003a FFF7FEFF 		bl	ESP8266_JoinAP
 299              	.LVL23:
 300              		.loc 1 74 8 discriminator 1 view .LVU48
 301 003e 0028     		cmp	r0, #0
 302 0040 F9D0     		beq	.L8
  75:./Hardware/ESP8266/bsp_esp8266_test.c **** 	
  76:./Hardware/ESP8266/bsp_esp8266_test.c ****   printf( "\r\nÁ¶ÅÊ≠¢Â§öËøûÊé• ......\r\n" );
 303              		.loc 1 76 3 is_stmt 1 view .LVU49
 304 0042 1748     		ldr	r0, .L13+28
ARM GAS  /tmp/ccRW1hdZ.s 			page 9


 305 0044 FFF7FEFF 		bl	puts
 306              	.LVL24:
  77:./Hardware/ESP8266/bsp_esp8266_test.c **** 	while( ! ESP8266_Enable_MultipleId ( DISABLE ) );
 307              		.loc 1 77 2 view .LVU50
 308              	.L9:
 309              		.loc 1 77 50 discriminator 1 view .LVU51
 310              		.loc 1 77 7 discriminator 1 view .LVU52
 311              		.loc 1 77 11 is_stmt 0 discriminator 1 view .LVU53
 312 0048 0020     		movs	r0, #0
 313 004a FFF7FEFF 		bl	ESP8266_Enable_MultipleId
 314              	.LVL25:
 315              		.loc 1 77 7 discriminator 1 view .LVU54
 316 004e 0028     		cmp	r0, #0
 317 0050 FAD0     		beq	.L9
  78:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  79:./Hardware/ESP8266/bsp_esp8266_test.c ****   printf( "\r\nÊ≠£Âú®ËøûÊé•ÊúçÂä°Âô® ......\r\n" );
 318              		.loc 1 79 3 is_stmt 1 view .LVU55
 319 0052 1448     		ldr	r0, .L13+32
 320 0054 FFF7FEFF 		bl	puts
 321              	.LVL26:
  80:./Hardware/ESP8266/bsp_esp8266_test.c **** 	while( !	ESP8266_Link_Server ( enumTCP, macUser_ESP8266_TcpServer_IP, macUser_ESP8266_TcpServer_Po
 322              		.loc 1 80 2 view .LVU56
 323              	.L10:
 324              		.loc 1 80 119 discriminator 1 view .LVU57
 325              		.loc 1 80 7 discriminator 1 view .LVU58
 326              		.loc 1 80 11 is_stmt 0 discriminator 1 view .LVU59
 327 0058 0523     		movs	r3, #5
 328 005a 134A     		ldr	r2, .L13+36
 329 005c 1349     		ldr	r1, .L13+40
 330 005e 0020     		movs	r0, #0
 331 0060 FFF7FEFF 		bl	ESP8266_Link_Server
 332              	.LVL27:
 333              		.loc 1 80 7 discriminator 1 view .LVU60
 334 0064 0028     		cmp	r0, #0
 335 0066 F7D0     		beq	.L10
  81:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  82:./Hardware/ESP8266/bsp_esp8266_test.c ****   printf( "\r\nËøõÂÖ•ÈÄè‰º†ÂèëÈÄÅÊ®°Âºè ......\r\n" );
 336              		.loc 1 82 3 is_stmt 1 view .LVU61
 337 0068 1148     		ldr	r0, .L13+44
 338 006a FFF7FEFF 		bl	puts
 339              	.LVL28:
  83:./Hardware/ESP8266/bsp_esp8266_test.c **** 	while( ! ESP8266_UnvarnishSend () );
 340              		.loc 1 83 2 view .LVU62
 341              	.L11:
 342              		.loc 1 83 37 discriminator 1 view .LVU63
 343              		.loc 1 83 7 discriminator 1 view .LVU64
 344              		.loc 1 83 11 is_stmt 0 discriminator 1 view .LVU65
 345 006e FFF7FEFF 		bl	ESP8266_UnvarnishSend
 346              	.LVL29:
 347              		.loc 1 83 7 discriminator 1 view .LVU66
 348 0072 0028     		cmp	r0, #0
 349 0074 FBD0     		beq	.L11
  84:./Hardware/ESP8266/bsp_esp8266_test.c **** 	
  85:./Hardware/ESP8266/bsp_esp8266_test.c **** 	printf( "\r\nÈÖçÁΩÆ ESP8266 ÂÆåÊØï\r\n" );
 350              		.loc 1 85 2 is_stmt 1 view .LVU67
 351 0076 0F48     		ldr	r0, .L13+48
 352 0078 FFF7FEFF 		bl	puts
ARM GAS  /tmp/ccRW1hdZ.s 			page 10


 353              	.LVL30:
  86:./Hardware/ESP8266/bsp_esp8266_test.c ****   
  87:./Hardware/ESP8266/bsp_esp8266_test.c **** 	printf ( "\r\nÂºÄÂßãÈÄè‰º†......\r\n" );
 354              		.loc 1 87 2 view .LVU68
 355 007c 0E48     		ldr	r0, .L13+52
 356 007e FFF7FEFF 		bl	puts
 357              	.LVL31:
  88:./Hardware/ESP8266/bsp_esp8266_test.c **** }
 358              		.loc 1 88 1 is_stmt 0 view .LVU69
 359 0082 08BD     		pop	{r3, pc}
 360              	.L14:
 361              		.align	2
 362              	.L13:
 363 0084 00000000 		.word	.LC9
 364 0088 20000000 		.word	.LC10
 365 008c 00000240 		.word	1073872896
 366 0090 38000000 		.word	.LC11
 367 0094 60000000 		.word	.LC12
 368 0098 7C000000 		.word	.LC13
 369 009c 88000000 		.word	.LC14
 370 00a0 94000000 		.word	.LC15
 371 00a4 B0000000 		.word	.LC16
 372 00a8 D0000000 		.word	.LC17
 373 00ac D4000000 		.word	.LC18
 374 00b0 E8000000 		.word	.LC19
 375 00b4 0C010000 		.word	.LC20
 376 00b8 28010000 		.word	.LC21
 377              		.cfi_endproc
 378              	.LFE740:
 380              		.section	.rodata.ESP8266_CheckRecvDataTest.str1.4,"aMS",%progbits,1
 381              		.align	2
 382              	.LC22:
 383 0000 0D0A5265 		.ascii	"\015\012Reconnecting to hotspot and server ......\015"
 383      636F6E6E 
 383      65637469 
 383      6E672074 
 383      6F20686F 
 384 002c 00       		.ascii	"\000"
 385 002d 000000   		.align	2
 386              	.LC23:
 387 0030 0D0A5265 		.ascii	"\015\012Reconnect to hotspot and server successfull"
 387      636F6E6E 
 387      65637420 
 387      746F2068 
 387      6F747370 
 388 005d 790D00   		.ascii	"y\015\000"
 389              		.section	.text.ESP8266_CheckRecvDataTest,"ax",%progbits
 390              		.align	1
 391              		.global	ESP8266_CheckRecvDataTest
 392              		.syntax unified
 393              		.thumb
 394              		.thumb_func
 395              		.fpu fpv4-sp-d16
 397              	ESP8266_CheckRecvDataTest:
 398              	.LFB741:
  89:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  90:./Hardware/ESP8266/bsp_esp8266_test.c **** /**************************************************************************************************
ARM GAS  /tmp/ccRW1hdZ.s 			page 11


  91:./Hardware/ESP8266/bsp_esp8266_test.c **** 
  92:./Hardware/ESP8266/bsp_esp8266_test.c **** /**
  93:./Hardware/ESP8266/bsp_esp8266_test.c ****   * @brief  ESP8266 Ê£ÄÊü•ÊòØÂê¶Êé•Êî∂Âà∞‰∫ÜÊï∞ÊçÆÔºåÊ£ÄÊü•ËøûÊé•ÂíåÊéâÁ∫øÈáçËøû
  94:./Hardware/ESP8266/bsp_esp8266_test.c ****   * @param  Êó†
  95:./Hardware/ESP8266/bsp_esp8266_test.c ****   * @retval Êó†
  96:./Hardware/ESP8266/bsp_esp8266_test.c ****   */
  97:./Hardware/ESP8266/bsp_esp8266_test.c **** void ESP8266_CheckRecvDataTest(void)
  98:./Hardware/ESP8266/bsp_esp8266_test.c **** {
 399              		.loc 1 98 1 is_stmt 1 view -0
 400              		.cfi_startproc
 401              		@ args = 0, pretend = 0, frame = 0
 402              		@ frame_needed = 0, uses_anonymous_args = 0
 403 0000 70B5     		push	{r4, r5, r6, lr}
 404              	.LCFI4:
 405              		.cfi_def_cfa_offset 16
 406              		.cfi_offset 4, -16
 407              		.cfi_offset 5, -12
 408              		.cfi_offset 6, -8
 409              		.cfi_offset 14, -4
  99:./Hardware/ESP8266/bsp_esp8266_test.c ****   uint8_t ucStatus;
 410              		.loc 1 99 3 view .LVU71
 100:./Hardware/ESP8266/bsp_esp8266_test.c **** 
 101:./Hardware/ESP8266/bsp_esp8266_test.c ****   if( strEsp8266_Fram_Record .InfBit .FramFinishFlag )   //Êé•Êî∂Âà∞Êï∞ÊçÆ
 411              		.loc 1 101 3 view .LVU72
 412              		.loc 1 101 38 is_stmt 0 view .LVU73
 413 0002 294B     		ldr	r3, .L28
 414 0004 B3F80034 		ldrh	r3, [r3, #1024]
 415              		.loc 1 101 5 view .LVU74
 416 0008 13F4004F 		tst	r3, #32768
 417 000c 25D0     		beq	.L16
 418              	.L17:
 419              		.file 2 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h"
   1:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
   2:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ******************************************************************************
   3:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @file    stm32f4xx_ll_usart.h
   4:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @author  MCD Application Team
   5:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief   Header file of USART LL module.
   6:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ******************************************************************************
   7:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @attention
   8:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *
   9:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * Copyright (c) 2016 STMicroelectronics.
  10:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * All rights reserved.
  11:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *
  12:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * This software is licensed under terms that can be found in the LICENSE file
  13:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * in the root directory of this software component.
  14:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * If no LICENSE file comes with this software, it is provided AS-IS.
  15:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *
  16:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ******************************************************************************
  17:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
  18:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  19:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /* Define to prevent recursive inclusion -------------------------------------*/
  20:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #ifndef __STM32F4xx_LL_USART_H
  21:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define __STM32F4xx_LL_USART_H
  22:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  23:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #ifdef __cplusplus
  24:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** extern "C" {
  25:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #endif
ARM GAS  /tmp/ccRW1hdZ.s 			page 12


  26:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  27:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /* Includes ------------------------------------------------------------------*/
  28:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #include "stm32f4xx.h"
  29:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  30:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @addtogroup STM32F4xx_LL_Driver
  31:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
  32:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
  33:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  34:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #if defined (USART1) || defined (USART2) || defined (USART3) || defined (USART6) || defined (UART4)
  35:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  36:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL USART
  37:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
  38:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
  39:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  40:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /* Private types -------------------------------------------------------------*/
  41:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /* Private variables ---------------------------------------------------------*/
  42:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  43:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /* Private constants ---------------------------------------------------------*/
  44:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_Private_Constants USART Private Constants
  45:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
  46:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
  47:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  48:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /* Defines used for the bit position in the register and perform offsets*/
  49:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define USART_POSITION_GTPR_GT                  USART_GTPR_GT_Pos
  50:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
  51:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
  52:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
  53:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  54:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /* Private macros ------------------------------------------------------------*/
  55:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #if defined(USE_FULL_LL_DRIVER)
  56:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_Private_Macros USART Private Macros
  57:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
  58:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
  59:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
  60:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
  61:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
  62:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #endif /*USE_FULL_LL_DRIVER*/
  63:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  64:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /* Exported types ------------------------------------------------------------*/
  65:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #if defined(USE_FULL_LL_DRIVER)
  66:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_ES_INIT USART Exported Init structures
  67:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
  68:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
  69:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  70:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
  71:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief LL USART Init Structure definition
  72:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
  73:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** typedef struct
  74:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
  75:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   uint32_t BaudRate;                  /*!< This field defines expected Usart communication baud rat
  76:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  77:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This feature can be modified afterwards using unitary fu
  78:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  79:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   uint32_t DataWidth;                 /*!< Specifies the number of data bits transmitted or receive
  80:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This parameter can be a value of @ref USART_LL_EC_DATAWI
  81:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  82:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This feature can be modified afterwards using unitary fu
ARM GAS  /tmp/ccRW1hdZ.s 			page 13


  83:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  84:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   uint32_t StopBits;                  /*!< Specifies the number of stop bits transmitted.
  85:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This parameter can be a value of @ref USART_LL_EC_STOPBI
  86:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  87:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This feature can be modified afterwards using unitary fu
  88:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  89:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   uint32_t Parity;                    /*!< Specifies the parity mode.
  90:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This parameter can be a value of @ref USART_LL_EC_PARITY
  91:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  92:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This feature can be modified afterwards using unitary fu
  93:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  94:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   uint32_t TransferDirection;         /*!< Specifies whether the Receive and/or Transmit mode is en
  95:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This parameter can be a value of @ref USART_LL_EC_DIRECT
  96:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  97:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This feature can be modified afterwards using unitary fu
  98:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
  99:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   uint32_t HardwareFlowControl;       /*!< Specifies whether the hardware flow control mode is enab
 100:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This parameter can be a value of @ref USART_LL_EC_HWCONT
 101:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 102:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This feature can be modified afterwards using unitary fu
 103:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 104:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   uint32_t OverSampling;              /*!< Specifies whether USART oversampling mode is 16 or 8.
 105:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This parameter can be a value of @ref USART_LL_EC_OVERSA
 106:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 107:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This feature can be modified afterwards using unitary fu
 108:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 109:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** } LL_USART_InitTypeDef;
 110:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 111:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 112:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief LL USART Clock Init Structure definition
 113:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 114:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** typedef struct
 115:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 116:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   uint32_t ClockOutput;               /*!< Specifies whether the USART clock is enabled or disabled
 117:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This parameter can be a value of @ref USART_LL_EC_CLOCK.
 118:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 119:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            USART HW configuration can be modified afterwards using 
 120:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            @ref LL_USART_EnableSCLKOutput() or @ref LL_USART_Disabl
 121:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            For more details, refer to description of this function.
 122:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 123:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   uint32_t ClockPolarity;             /*!< Specifies the steady state of the serial clock.
 124:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This parameter can be a value of @ref USART_LL_EC_POLARI
 125:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 126:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            USART HW configuration can be modified afterwards using 
 127:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            For more details, refer to description of this function.
 128:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 129:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   uint32_t ClockPhase;                /*!< Specifies the clock transition on which the bit capture 
 130:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This parameter can be a value of @ref USART_LL_EC_PHASE.
 131:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 132:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            USART HW configuration can be modified afterwards using 
 133:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            For more details, refer to description of this function.
 134:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 135:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   uint32_t LastBitClockPulse;         /*!< Specifies whether the clock pulse corresponding to the l
 136:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            data bit (MSB) has to be output on the SCLK pin in synch
 137:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            This parameter can be a value of @ref USART_LL_EC_LASTCL
 138:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 139:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            USART HW configuration can be modified afterwards using 
ARM GAS  /tmp/ccRW1hdZ.s 			page 14


 140:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                            For more details, refer to description of this function.
 141:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 142:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** } LL_USART_ClockInitTypeDef;
 143:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 144:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 145:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 146:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 147:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #endif /* USE_FULL_LL_DRIVER */
 148:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 149:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /* Exported constants --------------------------------------------------------*/
 150:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_Exported_Constants USART Exported Constants
 151:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 152:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 153:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 154:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_GET_FLAG Get Flags Defines
 155:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief    Flags defines which can be used with LL_USART_ReadReg function
 156:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 157:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 158:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_SR_PE                          USART_SR_PE                   /*!< Parity error fla
 159:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_SR_FE                          USART_SR_FE                   /*!< Framing error fl
 160:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_SR_NE                          USART_SR_NE                   /*!< Noise detected f
 161:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_SR_ORE                         USART_SR_ORE                  /*!< Overrun error fl
 162:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_SR_IDLE                        USART_SR_IDLE                 /*!< Idle line detect
 163:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_SR_RXNE                        USART_SR_RXNE                 /*!< Read data regist
 164:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_SR_TC                          USART_SR_TC                   /*!< Transmission com
 165:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_SR_TXE                         USART_SR_TXE                  /*!< Transmit data re
 166:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_SR_LBD                         USART_SR_LBD                  /*!< LIN break detect
 167:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_SR_CTS                         USART_SR_CTS                  /*!< CTS flag */
 168:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 169:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 170:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 171:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 172:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_IT IT Defines
 173:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief    IT defines which can be used with LL_USART_ReadReg and  LL_USART_WriteReg functions
 174:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 175:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 176:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_CR1_IDLEIE                     USART_CR1_IDLEIE              /*!< IDLE interrupt e
 177:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_CR1_RXNEIE                     USART_CR1_RXNEIE              /*!< Read data regist
 178:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_CR1_TCIE                       USART_CR1_TCIE                /*!< Transmission com
 179:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_CR1_TXEIE                      USART_CR1_TXEIE               /*!< Transmit data re
 180:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_CR1_PEIE                       USART_CR1_PEIE                /*!< Parity error */
 181:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_CR2_LBDIE                      USART_CR2_LBDIE               /*!< LIN break detect
 182:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_CR3_EIE                        USART_CR3_EIE                 /*!< Error interrupt 
 183:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_CR3_CTSIE                      USART_CR3_CTSIE               /*!< CTS interrupt en
 184:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 185:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 186:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 187:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 188:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_DIRECTION Communication Direction
 189:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 190:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 191:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_DIRECTION_NONE                 0x00000000U                        /*!< Transmitter
 192:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_DIRECTION_RX                   USART_CR1_RE                       /*!< Transmitter
 193:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_DIRECTION_TX                   USART_CR1_TE                       /*!< Transmitter
 194:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_DIRECTION_TX_RX                (USART_CR1_TE |USART_CR1_RE)       /*!< Transmitter
 195:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 196:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
ARM GAS  /tmp/ccRW1hdZ.s 			page 15


 197:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 198:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 199:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_PARITY Parity Control
 200:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 201:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 202:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_PARITY_NONE                    0x00000000U                          /*!< Parity co
 203:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_PARITY_EVEN                    USART_CR1_PCE                        /*!< Parity co
 204:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_PARITY_ODD                     (USART_CR1_PCE | USART_CR1_PS)       /*!< Parity co
 205:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 206:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 207:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 208:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 209:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_WAKEUP Wakeup
 210:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 211:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 212:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_WAKEUP_IDLELINE                0x00000000U           /*!<  USART wake up from Mute
 213:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_WAKEUP_ADDRESSMARK             USART_CR1_WAKE        /*!<  USART wake up from Mute
 214:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 215:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 216:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 217:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 218:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_DATAWIDTH Datawidth
 219:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 220:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 221:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_DATAWIDTH_8B                   0x00000000U             /*!< 8 bits word length : S
 222:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_DATAWIDTH_9B                   USART_CR1_M             /*!< 9 bits word length : S
 223:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 224:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 225:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 226:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 227:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_OVERSAMPLING Oversampling
 228:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 229:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 230:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_OVERSAMPLING_16                0x00000000U            /*!< Oversampling by 16 */
 231:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_OVERSAMPLING_8                 USART_CR1_OVER8        /*!< Oversampling by 8 */
 232:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 233:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 234:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 235:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 236:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #if defined(USE_FULL_LL_DRIVER)
 237:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_CLOCK Clock Signal
 238:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 239:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 240:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 241:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_CLOCK_DISABLE                  0x00000000U            /*!< Clock signal not provid
 242:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_CLOCK_ENABLE                   USART_CR2_CLKEN        /*!< Clock signal provided *
 243:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 244:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 245:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 246:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #endif /*USE_FULL_LL_DRIVER*/
 247:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 248:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_LASTCLKPULSE Last Clock Pulse
 249:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 250:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 251:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_LASTCLKPULSE_NO_OUTPUT         0x00000000U           /*!< The clock pulse of the l
 252:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_LASTCLKPULSE_OUTPUT            USART_CR2_LBCL        /*!< The clock pulse of the l
 253:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
ARM GAS  /tmp/ccRW1hdZ.s 			page 16


 254:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 255:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 256:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 257:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_PHASE Clock Phase
 258:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 259:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 260:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_PHASE_1EDGE                    0x00000000U           /*!< The first clock transiti
 261:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_PHASE_2EDGE                    USART_CR2_CPHA        /*!< The second clock transit
 262:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 263:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 264:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 265:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 266:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_POLARITY Clock Polarity
 267:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 268:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 269:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_POLARITY_LOW                   0x00000000U           /*!< Steady low value on SCLK
 270:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_POLARITY_HIGH                  USART_CR2_CPOL        /*!< Steady high value on SCL
 271:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 272:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 273:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 274:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 275:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_STOPBITS Stop Bits
 276:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 277:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 278:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_STOPBITS_0_5                   USART_CR2_STOP_0                           /*!< 0.5
 279:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_STOPBITS_1                     0x00000000U                                /*!< 1 s
 280:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_STOPBITS_1_5                   (USART_CR2_STOP_0 | USART_CR2_STOP_1)      /*!< 1.5
 281:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_STOPBITS_2                     USART_CR2_STOP_1                           /*!< 2 s
 282:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 283:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 284:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 285:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 286:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_HWCONTROL Hardware Control
 287:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 288:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 289:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_HWCONTROL_NONE                 0x00000000U                          /*!< CTS and R
 290:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_HWCONTROL_RTS                  USART_CR3_RTSE                       /*!< RTS outpu
 291:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_HWCONTROL_CTS                  USART_CR3_CTSE                       /*!< CTS mode 
 292:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_HWCONTROL_RTS_CTS              (USART_CR3_RTSE | USART_CR3_CTSE)    /*!< CTS and R
 293:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 294:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 295:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 296:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 297:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_IRDA_POWER IrDA Power
 298:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 299:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 300:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_IRDA_POWER_NORMAL              0x00000000U           /*!< IrDA normal power mode *
 301:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_IRDA_POWER_LOW                 USART_CR3_IRLP        /*!< IrDA low power mode */
 302:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 303:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 304:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 305:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 306:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EC_LINBREAK_DETECT LIN Break Detection Length
 307:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 308:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 309:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_LINBREAK_DETECT_10B            0x00000000U           /*!< 10-bit break detection m
 310:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_LINBREAK_DETECT_11B            USART_CR2_LBDL        /*!< 11-bit break detection m
ARM GAS  /tmp/ccRW1hdZ.s 			page 17


 311:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 312:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 313:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 314:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 315:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 316:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 317:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 318:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 319:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /* Exported macro ------------------------------------------------------------*/
 320:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_Exported_Macros USART Exported Macros
 321:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 322:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 323:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 324:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EM_WRITE_READ Common Write and read registers Macros
 325:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 326:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 327:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 328:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 329:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Write a value in USART register
 330:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  __INSTANCE__ USART Instance
 331:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  __REG__ Register to be written
 332:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  __VALUE__ Value to be written in the register
 333:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 334:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 335:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VAL
 336:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 337:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 338:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Read a value in USART register
 339:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  __INSTANCE__ USART Instance
 340:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  __REG__ Register to be read
 341:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Register value
 342:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 343:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define LL_USART_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
 344:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 345:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 346:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 347:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 348:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EM_Exported_Macros_Helper Exported_Macros_Helper
 349:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 350:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 351:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 352:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 353:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Compute USARTDIV value according to Peripheral Clock and
 354:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         expected Baud Rate in 8 bits sampling mode (32 bits value of USARTDIV is returned)
 355:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  __PERIPHCLK__ Peripheral Clock frequency used for USART instance
 356:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  __BAUDRATE__ Baud rate value to achieve
 357:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval USARTDIV value to be used for BRR register filling in OverSampling_8 case
 358:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 359:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define __LL_USART_DIV_SAMPLING8_100(__PERIPHCLK__, __BAUDRATE__)      ((uint32_t)((((uint64_t)(__P
 360:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define __LL_USART_DIVMANT_SAMPLING8(__PERIPHCLK__, __BAUDRATE__)      (__LL_USART_DIV_SAMPLING8_10
 361:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define __LL_USART_DIVFRAQ_SAMPLING8(__PERIPHCLK__, __BAUDRATE__)      ((((__LL_USART_DIV_SAMPLING8
 362:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                                                          + 50) / 100)
 363:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /* UART BRR = mantissa + overflow + fraction
 364:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****             = (UART DIVMANT << 4) + ((UART DIVFRAQ & 0xF8) << 1) + (UART DIVFRAQ & 0x07) */
 365:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define __LL_USART_DIV_SAMPLING8(__PERIPHCLK__, __BAUDRATE__)             (((__LL_USART_DIVMANT_SAM
 366:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                                                             ((__LL_USART_DIVFRAQ_SA
 367:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                                                            (__LL_USART_DIVFRAQ_SAMP
ARM GAS  /tmp/ccRW1hdZ.s 			page 18


 368:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 369:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 370:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Compute USARTDIV value according to Peripheral Clock and
 371:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         expected Baud Rate in 16 bits sampling mode (32 bits value of USARTDIV is returned)
 372:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  __PERIPHCLK__ Peripheral Clock frequency used for USART instance
 373:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  __BAUDRATE__ Baud rate value to achieve
 374:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval USARTDIV value to be used for BRR register filling in OverSampling_16 case
 375:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 376:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define __LL_USART_DIV_SAMPLING16_100(__PERIPHCLK__, __BAUDRATE__)     ((uint32_t)((((uint64_t)(__P
 377:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define __LL_USART_DIVMANT_SAMPLING16(__PERIPHCLK__, __BAUDRATE__)     (__LL_USART_DIV_SAMPLING16_1
 378:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define __LL_USART_DIVFRAQ_SAMPLING16(__PERIPHCLK__, __BAUDRATE__)     ((((__LL_USART_DIV_SAMPLING1
 379:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                                                          + 50) / 100)
 380:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /* USART BRR = mantissa + overflow + fraction
 381:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****             = (USART DIVMANT << 4) + (USART DIVFRAQ & 0xF0) + (USART DIVFRAQ & 0x0F) */
 382:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** #define __LL_USART_DIV_SAMPLING16(__PERIPHCLK__, __BAUDRATE__)            (((__LL_USART_DIVMANT_SAM
 383:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                                                             (__LL_USART_DIVFRAQ_SAM
 384:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                                                            (__LL_USART_DIVFRAQ_SAMP
 385:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 386:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 387:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 388:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 389:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 390:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 391:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
 392:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 393:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 394:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /* Exported functions --------------------------------------------------------*/
 395:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 396:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_Exported_Functions USART Exported Functions
 397:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 398:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 399:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 400:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EF_Configuration Configuration functions
 401:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
 402:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 403:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 404:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 405:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  USART Enable
 406:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          UE            LL_USART_Enable
 407:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 408:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 409:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 410:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_Enable(USART_TypeDef *USARTx)
 411:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 412:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR1, USART_CR1_UE);
 413:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 414:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 415:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 416:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  USART Disable (all USART prescalers and outputs are disabled)
 417:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   When USART is disabled, USART prescalers and outputs are stopped immediately,
 418:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         and current operations are discarded. The configuration of the USART is kept, but all t
 419:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         flags, in the USARTx_SR are set to their default values.
 420:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          UE            LL_USART_Disable
 421:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 422:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 423:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 424:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_Disable(USART_TypeDef *USARTx)
ARM GAS  /tmp/ccRW1hdZ.s 			page 19


 425:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 426:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR1, USART_CR1_UE);
 427:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 428:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 429:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 430:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Indicate if USART is enabled
 431:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          UE            LL_USART_IsEnabled
 432:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 433:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
 434:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 435:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsEnabled(USART_TypeDef *USARTx)
 436:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 437:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE));
 438:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 439:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 440:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 441:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Receiver Enable (Receiver is enabled and begins searching for a start bit)
 442:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          RE            LL_USART_EnableDirectionRx
 443:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 444:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 445:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 446:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableDirectionRx(USART_TypeDef *USARTx)
 447:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 448:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RE);
 449:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 450:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 451:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 452:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Receiver Disable
 453:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          RE            LL_USART_DisableDirectionRx
 454:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 455:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 456:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 457:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_DisableDirectionRx(USART_TypeDef *USARTx)
 458:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 459:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RE);
 460:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 461:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 462:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 463:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Transmitter Enable
 464:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          TE            LL_USART_EnableDirectionTx
 465:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 466:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 467:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 468:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableDirectionTx(USART_TypeDef *USARTx)
 469:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 470:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TE);
 471:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 472:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 473:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 474:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Transmitter Disable
 475:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          TE            LL_USART_DisableDirectionTx
 476:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 477:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 478:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 479:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_DisableDirectionTx(USART_TypeDef *USARTx)
 480:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 481:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TE);
ARM GAS  /tmp/ccRW1hdZ.s 			page 20


 482:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 483:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 484:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 485:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Configure simultaneously enabled/disabled states
 486:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         of Transmitter and Receiver
 487:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          RE            LL_USART_SetTransferDirection\n
 488:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR1          TE            LL_USART_SetTransferDirection
 489:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 490:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  TransferDirection This parameter can be one of the following values:
 491:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DIRECTION_NONE
 492:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DIRECTION_RX
 493:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DIRECTION_TX
 494:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DIRECTION_TX_RX
 495:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 496:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 497:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetTransferDirection(USART_TypeDef *USARTx, uint32_t TransferDirectio
 498:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 499:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 500:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 501:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 502:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 503:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return enabled/disabled states of Transmitter and Receiver
 504:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          RE            LL_USART_GetTransferDirection\n
 505:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR1          TE            LL_USART_GetTransferDirection
 506:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 507:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Returned value can be one of the following values:
 508:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DIRECTION_NONE
 509:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DIRECTION_RX
 510:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DIRECTION_TX
 511:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DIRECTION_TX_RX
 512:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 513:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetTransferDirection(USART_TypeDef *USARTx)
 514:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 515:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_RE | USART_CR1_TE));
 516:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 517:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 518:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 519:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Configure Parity (enabled/disabled and parity mode if enabled).
 520:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   This function selects if hardware parity control (generation and detection) is enabled 
 521:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         When the parity control is enabled (Odd or Even), computed parity bit is inserted at th
 522:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (9th or 8th bit depending on data width) and parity is checked on the received data.
 523:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          PS            LL_USART_SetParity\n
 524:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR1          PCE           LL_USART_SetParity
 525:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 526:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  Parity This parameter can be one of the following values:
 527:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PARITY_NONE
 528:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PARITY_EVEN
 529:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PARITY_ODD
 530:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 531:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 532:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetParity(USART_TypeDef *USARTx, uint32_t Parity)
 533:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 534:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE, Parity);
 535:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 536:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 537:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 538:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return Parity configuration (enabled/disabled and parity mode if enabled)
ARM GAS  /tmp/ccRW1hdZ.s 			page 21


 539:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          PS            LL_USART_GetParity\n
 540:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR1          PCE           LL_USART_GetParity
 541:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 542:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Returned value can be one of the following values:
 543:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PARITY_NONE
 544:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PARITY_EVEN
 545:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PARITY_ODD
 546:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 547:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetParity(USART_TypeDef *USARTx)
 548:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 549:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
 550:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 551:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 552:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 553:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Set Receiver Wake Up method from Mute mode.
 554:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          WAKE          LL_USART_SetWakeUpMethod
 555:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 556:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  Method This parameter can be one of the following values:
 557:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_WAKEUP_IDLELINE
 558:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_WAKEUP_ADDRESSMARK
 559:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 560:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 561:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetWakeUpMethod(USART_TypeDef *USARTx, uint32_t Method)
 562:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 563:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR1, USART_CR1_WAKE, Method);
 564:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 565:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 566:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 567:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return Receiver Wake Up method from Mute mode
 568:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          WAKE          LL_USART_GetWakeUpMethod
 569:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 570:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Returned value can be one of the following values:
 571:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_WAKEUP_IDLELINE
 572:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_WAKEUP_ADDRESSMARK
 573:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 574:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetWakeUpMethod(USART_TypeDef *USARTx)
 575:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 576:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_WAKE));
 577:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 578:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 579:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 580:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Set Word length (i.e. nb of data bits, excluding start and stop bits)
 581:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          M             LL_USART_SetDataWidth
 582:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 583:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  DataWidth This parameter can be one of the following values:
 584:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DATAWIDTH_8B
 585:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DATAWIDTH_9B
 586:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 587:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 588:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetDataWidth(USART_TypeDef *USARTx, uint32_t DataWidth)
 589:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 590:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR1, USART_CR1_M, DataWidth);
 591:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 592:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 593:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 594:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return Word length (i.e. nb of data bits, excluding start and stop bits)
 595:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          M             LL_USART_GetDataWidth
ARM GAS  /tmp/ccRW1hdZ.s 			page 22


 596:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 597:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Returned value can be one of the following values:
 598:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DATAWIDTH_8B
 599:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DATAWIDTH_9B
 600:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 601:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetDataWidth(USART_TypeDef *USARTx)
 602:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 603:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
 604:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 605:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 606:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 607:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Set Oversampling to 8-bit or 16-bit mode
 608:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          OVER8         LL_USART_SetOverSampling
 609:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 610:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  OverSampling This parameter can be one of the following values:
 611:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_OVERSAMPLING_16
 612:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_OVERSAMPLING_8
 613:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 614:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 615:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetOverSampling(USART_TypeDef *USARTx, uint32_t OverSampling)
 616:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 617:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR1, USART_CR1_OVER8, OverSampling);
 618:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 619:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 620:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 621:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return Oversampling mode
 622:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          OVER8         LL_USART_GetOverSampling
 623:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 624:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Returned value can be one of the following values:
 625:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_OVERSAMPLING_16
 626:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_OVERSAMPLING_8
 627:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 628:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetOverSampling(USART_TypeDef *USARTx)
 629:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 630:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_OVER8));
 631:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 632:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 633:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 634:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Configure if Clock pulse of the last data bit is output to the SCLK pin or not
 635:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
 636:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Synchronous mode is supported by the USARTx instance.
 637:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LBCL          LL_USART_SetLastClkPulseOutput
 638:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 639:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  LastBitClockPulse This parameter can be one of the following values:
 640:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_LASTCLKPULSE_NO_OUTPUT
 641:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_LASTCLKPULSE_OUTPUT
 642:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 643:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 644:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetLastClkPulseOutput(USART_TypeDef *USARTx, uint32_t LastBitClockPul
 645:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 646:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR2, USART_CR2_LBCL, LastBitClockPulse);
 647:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 648:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 649:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 650:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Retrieve Clock pulse of the last data bit output configuration
 651:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (Last bit Clock pulse output to the SCLK pin or not)
 652:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
ARM GAS  /tmp/ccRW1hdZ.s 			page 23


 653:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Synchronous mode is supported by the USARTx instance.
 654:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LBCL          LL_USART_GetLastClkPulseOutput
 655:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 656:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Returned value can be one of the following values:
 657:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_LASTCLKPULSE_NO_OUTPUT
 658:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_LASTCLKPULSE_OUTPUT
 659:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 660:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetLastClkPulseOutput(USART_TypeDef *USARTx)
 661:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 662:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_LBCL));
 663:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 664:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 665:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 666:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Select the phase of the clock output on the SCLK pin in synchronous mode
 667:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
 668:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Synchronous mode is supported by the USARTx instance.
 669:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          CPHA          LL_USART_SetClockPhase
 670:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 671:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  ClockPhase This parameter can be one of the following values:
 672:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PHASE_1EDGE
 673:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PHASE_2EDGE
 674:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 675:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 676:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetClockPhase(USART_TypeDef *USARTx, uint32_t ClockPhase)
 677:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 678:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR2, USART_CR2_CPHA, ClockPhase);
 679:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 680:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 681:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 682:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return phase of the clock output on the SCLK pin in synchronous mode
 683:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
 684:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Synchronous mode is supported by the USARTx instance.
 685:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          CPHA          LL_USART_GetClockPhase
 686:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 687:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Returned value can be one of the following values:
 688:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PHASE_1EDGE
 689:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PHASE_2EDGE
 690:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 691:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetClockPhase(USART_TypeDef *USARTx)
 692:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 693:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_CPHA));
 694:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 695:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 696:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 697:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Select the polarity of the clock output on the SCLK pin in synchronous mode
 698:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
 699:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Synchronous mode is supported by the USARTx instance.
 700:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          CPOL          LL_USART_SetClockPolarity
 701:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 702:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  ClockPolarity This parameter can be one of the following values:
 703:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_POLARITY_LOW
 704:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_POLARITY_HIGH
 705:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 706:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 707:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetClockPolarity(USART_TypeDef *USARTx, uint32_t ClockPolarity)
 708:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 709:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR2, USART_CR2_CPOL, ClockPolarity);
ARM GAS  /tmp/ccRW1hdZ.s 			page 24


 710:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 711:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 712:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 713:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return polarity of the clock output on the SCLK pin in synchronous mode
 714:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
 715:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Synchronous mode is supported by the USARTx instance.
 716:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          CPOL          LL_USART_GetClockPolarity
 717:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 718:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Returned value can be one of the following values:
 719:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_POLARITY_LOW
 720:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_POLARITY_HIGH
 721:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 722:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetClockPolarity(USART_TypeDef *USARTx)
 723:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 724:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_CPOL));
 725:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 726:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 727:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 728:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Configure Clock signal format (Phase Polarity and choice about output of last bit clock
 729:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
 730:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Synchronous mode is supported by the USARTx instance.
 731:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Call of this function is equivalent to following function call sequence :
 732:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clock Phase configuration using @ref LL_USART_SetClockPhase() function
 733:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clock Polarity configuration using @ref LL_USART_SetClockPolarity() function
 734:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Output of Last bit Clock pulse configuration using @ref LL_USART_SetLastClkPulseOutpu
 735:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          CPHA          LL_USART_ConfigClock\n
 736:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR2          CPOL          LL_USART_ConfigClock\n
 737:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR2          LBCL          LL_USART_ConfigClock
 738:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 739:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  Phase This parameter can be one of the following values:
 740:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PHASE_1EDGE
 741:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PHASE_2EDGE
 742:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  Polarity This parameter can be one of the following values:
 743:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_POLARITY_LOW
 744:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_POLARITY_HIGH
 745:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  LBCPOutput This parameter can be one of the following values:
 746:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_LASTCLKPULSE_NO_OUTPUT
 747:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_LASTCLKPULSE_OUTPUT
 748:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 749:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 750:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ConfigClock(USART_TypeDef *USARTx, uint32_t Phase, uint32_t Polarity,
 751:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 752:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR2, USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_LBCL, Phase | Polarity | LBCP
 753:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 754:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 755:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 756:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable Clock output on SCLK pin
 757:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
 758:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Synchronous mode is supported by the USARTx instance.
 759:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          CLKEN         LL_USART_EnableSCLKOutput
 760:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 761:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 762:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 763:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableSCLKOutput(USART_TypeDef *USARTx)
 764:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 765:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR2, USART_CR2_CLKEN);
 766:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
ARM GAS  /tmp/ccRW1hdZ.s 			page 25


 767:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 768:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 769:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Disable Clock output on SCLK pin
 770:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
 771:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Synchronous mode is supported by the USARTx instance.
 772:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          CLKEN         LL_USART_DisableSCLKOutput
 773:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 774:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 775:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 776:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_DisableSCLKOutput(USART_TypeDef *USARTx)
 777:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 778:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR2, USART_CR2_CLKEN);
 779:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 780:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 781:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 782:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Indicate if Clock output on SCLK pin is enabled
 783:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
 784:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Synchronous mode is supported by the USARTx instance.
 785:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          CLKEN         LL_USART_IsEnabledSCLKOutput
 786:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 787:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
 788:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 789:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsEnabledSCLKOutput(USART_TypeDef *USARTx)
 790:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 791:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->CR2, USART_CR2_CLKEN) == (USART_CR2_CLKEN));
 792:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 793:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 794:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 795:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Set the length of the stop bits
 796:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          STOP          LL_USART_SetStopBitsLength
 797:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 798:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  StopBits This parameter can be one of the following values:
 799:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_STOPBITS_0_5
 800:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_STOPBITS_1
 801:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_STOPBITS_1_5
 802:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_STOPBITS_2
 803:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 804:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 805:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetStopBitsLength(USART_TypeDef *USARTx, uint32_t StopBits)
 806:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 807:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 808:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 809:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 810:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 811:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Retrieve the length of the stop bits
 812:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          STOP          LL_USART_GetStopBitsLength
 813:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 814:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Returned value can be one of the following values:
 815:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_STOPBITS_0_5
 816:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_STOPBITS_1
 817:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_STOPBITS_1_5
 818:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_STOPBITS_2
 819:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 820:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetStopBitsLength(USART_TypeDef *USARTx)
 821:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 822:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
 823:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
ARM GAS  /tmp/ccRW1hdZ.s 			page 26


 824:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 825:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 826:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Configure Character frame format (Datawidth, Parity control, Stop Bits)
 827:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Call of this function is equivalent to following function call sequence :
 828:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Data Width configuration using @ref LL_USART_SetDataWidth() function
 829:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Parity Control and mode configuration using @ref LL_USART_SetParity() function
 830:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Stop bits configuration using @ref LL_USART_SetStopBitsLength() function
 831:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          PS            LL_USART_ConfigCharacter\n
 832:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR1          PCE           LL_USART_ConfigCharacter\n
 833:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR1          M             LL_USART_ConfigCharacter\n
 834:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR2          STOP          LL_USART_ConfigCharacter
 835:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 836:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  DataWidth This parameter can be one of the following values:
 837:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DATAWIDTH_8B
 838:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_DATAWIDTH_9B
 839:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  Parity This parameter can be one of the following values:
 840:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PARITY_NONE
 841:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PARITY_EVEN
 842:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PARITY_ODD
 843:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  StopBits This parameter can be one of the following values:
 844:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_STOPBITS_0_5
 845:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_STOPBITS_1
 846:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_STOPBITS_1_5
 847:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_STOPBITS_2
 848:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 849:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 850:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ConfigCharacter(USART_TypeDef *USARTx, uint32_t DataWidth, uint32_t P
 851:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                               uint32_t StopBits)
 852:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 853:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
 854:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 855:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 856:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 857:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 858:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Set Address of the USART node.
 859:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   This is used in multiprocessor communication during Mute mode or Stop mode,
 860:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         for wake up with address mark detection.
 861:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          ADD           LL_USART_SetNodeAddress
 862:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 863:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  NodeAddress 4 bit Address of the USART node.
 864:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 865:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 866:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetNodeAddress(USART_TypeDef *USARTx, uint32_t NodeAddress)
 867:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 868:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR2, USART_CR2_ADD, (NodeAddress & USART_CR2_ADD));
 869:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 870:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 871:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 872:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return 4 bit Address of the USART node as set in ADD field of CR2.
 873:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   only 4bits (b3-b0) of returned value are relevant (b31-b4 are not relevant)
 874:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          ADD           LL_USART_GetNodeAddress
 875:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 876:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Address of the USART node (Value between Min_Data=0 and Max_Data=255)
 877:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 878:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetNodeAddress(USART_TypeDef *USARTx)
 879:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 880:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_ADD));
ARM GAS  /tmp/ccRW1hdZ.s 			page 27


 881:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 882:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 883:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 884:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable RTS HW Flow Control
 885:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
 886:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Hardware Flow control feature is supported by the USARTx instance.
 887:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          RTSE          LL_USART_EnableRTSHWFlowCtrl
 888:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 889:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 890:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 891:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableRTSHWFlowCtrl(USART_TypeDef *USARTx)
 892:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 893:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR3, USART_CR3_RTSE);
 894:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 895:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 896:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 897:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Disable RTS HW Flow Control
 898:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
 899:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Hardware Flow control feature is supported by the USARTx instance.
 900:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          RTSE          LL_USART_DisableRTSHWFlowCtrl
 901:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 902:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 903:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 904:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_DisableRTSHWFlowCtrl(USART_TypeDef *USARTx)
 905:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 906:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, USART_CR3_RTSE);
 907:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 908:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 909:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 910:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable CTS HW Flow Control
 911:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
 912:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Hardware Flow control feature is supported by the USARTx instance.
 913:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          CTSE          LL_USART_EnableCTSHWFlowCtrl
 914:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 915:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 916:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 917:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableCTSHWFlowCtrl(USART_TypeDef *USARTx)
 918:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 919:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR3, USART_CR3_CTSE);
 920:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 921:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 922:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 923:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Disable CTS HW Flow Control
 924:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
 925:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Hardware Flow control feature is supported by the USARTx instance.
 926:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          CTSE          LL_USART_DisableCTSHWFlowCtrl
 927:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 928:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 929:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 930:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_DisableCTSHWFlowCtrl(USART_TypeDef *USARTx)
 931:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 932:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, USART_CR3_CTSE);
 933:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 934:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 935:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 936:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Configure HW Flow Control mode (both CTS and RTS)
 937:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
ARM GAS  /tmp/ccRW1hdZ.s 			page 28


 938:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Hardware Flow control feature is supported by the USARTx instance.
 939:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          RTSE          LL_USART_SetHWFlowCtrl\n
 940:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          CTSE          LL_USART_SetHWFlowCtrl
 941:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 942:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  HardwareFlowControl This parameter can be one of the following values:
 943:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_HWCONTROL_NONE
 944:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_HWCONTROL_RTS
 945:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_HWCONTROL_CTS
 946:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
 947:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 948:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 949:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetHWFlowCtrl(USART_TypeDef *USARTx, uint32_t HardwareFlowControl)
 950:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 951:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 952:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 953:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 954:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 955:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return HW Flow Control configuration (both CTS and RTS)
 956:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
 957:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Hardware Flow control feature is supported by the USARTx instance.
 958:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          RTSE          LL_USART_GetHWFlowCtrl\n
 959:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          CTSE          LL_USART_GetHWFlowCtrl
 960:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 961:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Returned value can be one of the following values:
 962:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_HWCONTROL_NONE
 963:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_HWCONTROL_RTS
 964:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_HWCONTROL_CTS
 965:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
 966:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 967:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetHWFlowCtrl(USART_TypeDef *USARTx)
 968:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 969:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
 970:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 971:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 972:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 973:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable One bit sampling method
 974:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          ONEBIT        LL_USART_EnableOneBitSamp
 975:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 976:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 977:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 978:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableOneBitSamp(USART_TypeDef *USARTx)
 979:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 980:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR3, USART_CR3_ONEBIT);
 981:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 982:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 983:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
 984:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Disable One bit sampling method
 985:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          ONEBIT        LL_USART_DisableOneBitSamp
 986:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 987:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
 988:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
 989:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_DisableOneBitSamp(USART_TypeDef *USARTx)
 990:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 991:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, USART_CR3_ONEBIT);
 992:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 993:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
 994:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
ARM GAS  /tmp/ccRW1hdZ.s 			page 29


 995:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Indicate if One bit sampling method is enabled
 996:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          ONEBIT        LL_USART_IsEnabledOneBitSamp
 997:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
 998:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
 999:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1000:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsEnabledOneBitSamp(USART_TypeDef *USARTx)
1001:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1002:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->CR3, USART_CR3_ONEBIT) == (USART_CR3_ONEBIT));
1003:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1004:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1005:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1006:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Configure USART BRR register for achieving expected Baud Rate value.
1007:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Compute and set USARTDIV value in BRR Register (full BRR content)
1008:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         according to used Peripheral Clock, Oversampling mode, and expected Baud Rate values
1009:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Peripheral clock and Baud rate values provided as function parameters should be valid
1010:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (Baud rate value != 0)
1011:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll BRR          BRR           LL_USART_SetBaudRate
1012:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1013:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  PeriphClk Peripheral Clock
1014:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  OverSampling This parameter can be one of the following values:
1015:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_OVERSAMPLING_16
1016:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_OVERSAMPLING_8
1017:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  BaudRate Baud Rate
1018:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1019:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1020:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverS
1021:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****                                           uint32_t BaudRate)
1022:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1023:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   if (OverSampling == LL_USART_OVERSAMPLING_8)
1024:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   {
1025:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
1026:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   }
1027:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   else
1028:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   {
1029:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
1030:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   }
1031:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1032:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1033:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1034:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return current Baud Rate value, according to USARTDIV present in BRR register
1035:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (full BRR content), and to used Peripheral Clock and Oversampling mode values
1036:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   In case of non-initialized or invalid value stored in BRR register, value 0 will be ret
1037:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll BRR          BRR           LL_USART_GetBaudRate
1038:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1039:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  PeriphClk Peripheral Clock
1040:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  OverSampling This parameter can be one of the following values:
1041:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_OVERSAMPLING_16
1042:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_OVERSAMPLING_8
1043:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Baud Rate
1044:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1045:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t O
1046:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1047:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   uint32_t usartdiv = 0x0U;
1048:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   uint32_t brrresult = 0x0U;
1049:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1050:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   usartdiv = USARTx->BRR;
1051:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
ARM GAS  /tmp/ccRW1hdZ.s 			page 30


1052:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   if (OverSampling == LL_USART_OVERSAMPLING_8)
1053:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   {
1054:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****     if ((usartdiv & 0xFFF7U) != 0U)
1055:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****     {
1056:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****       usartdiv = (uint16_t)((usartdiv & 0xFFF0U) | ((usartdiv & 0x0007U) << 1U)) ;
1057:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****       brrresult = (PeriphClk * 2U) / usartdiv;
1058:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****     }
1059:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   }
1060:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   else
1061:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   {
1062:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****     if ((usartdiv & 0xFFFFU) != 0U)
1063:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****     {
1064:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****       brrresult = PeriphClk / usartdiv;
1065:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****     }
1066:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   }
1067:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (brrresult);
1068:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1069:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1070:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1071:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
1072:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1073:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1074:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EF_Configuration_IRDA Configuration functions related to Irda feature
1075:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
1076:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1077:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1078:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1079:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable IrDA mode
1080:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
1081:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         IrDA feature is supported by the USARTx instance.
1082:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          IREN          LL_USART_EnableIrda
1083:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1084:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1085:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1086:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableIrda(USART_TypeDef *USARTx)
1087:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1088:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR3, USART_CR3_IREN);
1089:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1090:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1091:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1092:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Disable IrDA mode
1093:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
1094:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         IrDA feature is supported by the USARTx instance.
1095:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          IREN          LL_USART_DisableIrda
1096:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1097:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1098:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1099:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_DisableIrda(USART_TypeDef *USARTx)
1100:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1101:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, USART_CR3_IREN);
1102:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1103:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1104:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1105:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Indicate if IrDA mode is enabled
1106:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
1107:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         IrDA feature is supported by the USARTx instance.
1108:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          IREN          LL_USART_IsEnabledIrda
ARM GAS  /tmp/ccRW1hdZ.s 			page 31


1109:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1110:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1111:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1112:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsEnabledIrda(USART_TypeDef *USARTx)
1113:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1114:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->CR3, USART_CR3_IREN) == (USART_CR3_IREN));
1115:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1116:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1117:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1118:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Configure IrDA Power Mode (Normal or Low Power)
1119:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
1120:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         IrDA feature is supported by the USARTx instance.
1121:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          IRLP          LL_USART_SetIrdaPowerMode
1122:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1123:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  PowerMode This parameter can be one of the following values:
1124:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_IRDA_POWER_NORMAL
1125:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_IRDA_POWER_LOW
1126:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1127:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1128:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetIrdaPowerMode(USART_TypeDef *USARTx, uint32_t PowerMode)
1129:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1130:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR3, USART_CR3_IRLP, PowerMode);
1131:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1132:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1133:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1134:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Retrieve IrDA Power Mode configuration (Normal or Low Power)
1135:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
1136:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         IrDA feature is supported by the USARTx instance.
1137:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          IRLP          LL_USART_GetIrdaPowerMode
1138:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1139:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Returned value can be one of the following values:
1140:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_IRDA_POWER_NORMAL
1141:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_PHASE_2EDGE
1142:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1143:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetIrdaPowerMode(USART_TypeDef *USARTx)
1144:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1145:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_IRLP));
1146:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1147:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1148:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1149:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Set Irda prescaler value, used for dividing the USART clock source
1150:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         to achieve the Irda Low Power frequency (8 bits value)
1151:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
1152:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         IrDA feature is supported by the USARTx instance.
1153:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll GTPR         PSC           LL_USART_SetIrdaPrescaler
1154:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1155:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  PrescalerValue Value between Min_Data=0x00 and Max_Data=0xFF
1156:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1157:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1158:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetIrdaPrescaler(USART_TypeDef *USARTx, uint32_t PrescalerValue)
1159:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1160:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->GTPR, USART_GTPR_PSC, PrescalerValue);
1161:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1162:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1163:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1164:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return Irda prescaler value, used for dividing the USART clock source
1165:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         to achieve the Irda Low Power frequency (8 bits value)
ARM GAS  /tmp/ccRW1hdZ.s 			page 32


1166:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
1167:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         IrDA feature is supported by the USARTx instance.
1168:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll GTPR         PSC           LL_USART_GetIrdaPrescaler
1169:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1170:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Irda prescaler value (Value between Min_Data=0x00 and Max_Data=0xFF)
1171:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1172:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetIrdaPrescaler(USART_TypeDef *USARTx)
1173:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1174:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->GTPR, USART_GTPR_PSC));
1175:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1176:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1177:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1178:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
1179:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1180:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1181:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EF_Configuration_Smartcard Configuration functions related to Smartcard feat
1182:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
1183:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1184:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1185:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1186:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable Smartcard NACK transmission
1187:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
1188:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Smartcard feature is supported by the USARTx instance.
1189:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          NACK          LL_USART_EnableSmartcardNACK
1190:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1191:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1192:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1193:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableSmartcardNACK(USART_TypeDef *USARTx)
1194:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1195:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR3, USART_CR3_NACK);
1196:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1197:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1198:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1199:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Disable Smartcard NACK transmission
1200:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
1201:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Smartcard feature is supported by the USARTx instance.
1202:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          NACK          LL_USART_DisableSmartcardNACK
1203:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1204:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1205:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1206:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_DisableSmartcardNACK(USART_TypeDef *USARTx)
1207:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1208:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, USART_CR3_NACK);
1209:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1210:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1211:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1212:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Indicate if Smartcard NACK transmission is enabled
1213:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
1214:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Smartcard feature is supported by the USARTx instance.
1215:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          NACK          LL_USART_IsEnabledSmartcardNACK
1216:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1217:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1218:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1219:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsEnabledSmartcardNACK(USART_TypeDef *USARTx)
1220:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1221:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->CR3, USART_CR3_NACK) == (USART_CR3_NACK));
1222:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
ARM GAS  /tmp/ccRW1hdZ.s 			page 33


1223:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1224:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1225:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable Smartcard mode
1226:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
1227:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Smartcard feature is supported by the USARTx instance.
1228:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          SCEN          LL_USART_EnableSmartcard
1229:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1230:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1231:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1232:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableSmartcard(USART_TypeDef *USARTx)
1233:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1234:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR3, USART_CR3_SCEN);
1235:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1236:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1237:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1238:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Disable Smartcard mode
1239:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
1240:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Smartcard feature is supported by the USARTx instance.
1241:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          SCEN          LL_USART_DisableSmartcard
1242:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1243:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1244:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1245:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_DisableSmartcard(USART_TypeDef *USARTx)
1246:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1247:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, USART_CR3_SCEN);
1248:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1249:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1250:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1251:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Indicate if Smartcard mode is enabled
1252:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
1253:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Smartcard feature is supported by the USARTx instance.
1254:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          SCEN          LL_USART_IsEnabledSmartcard
1255:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1256:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1257:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1258:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsEnabledSmartcard(USART_TypeDef *USARTx)
1259:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1260:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->CR3, USART_CR3_SCEN) == (USART_CR3_SCEN));
1261:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1262:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1263:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1264:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Set Smartcard prescaler value, used for dividing the USART clock
1265:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         source to provide the SMARTCARD Clock (5 bits value)
1266:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
1267:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Smartcard feature is supported by the USARTx instance.
1268:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll GTPR         PSC           LL_USART_SetSmartcardPrescaler
1269:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1270:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  PrescalerValue Value between Min_Data=0 and Max_Data=31
1271:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1272:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1273:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetSmartcardPrescaler(USART_TypeDef *USARTx, uint32_t PrescalerValue)
1274:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1275:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->GTPR, USART_GTPR_PSC, PrescalerValue);
1276:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1277:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1278:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1279:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return Smartcard prescaler value, used for dividing the USART clock
ARM GAS  /tmp/ccRW1hdZ.s 			page 34


1280:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         source to provide the SMARTCARD Clock (5 bits value)
1281:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
1282:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Smartcard feature is supported by the USARTx instance.
1283:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll GTPR         PSC           LL_USART_GetSmartcardPrescaler
1284:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1285:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Smartcard prescaler value (Value between Min_Data=0 and Max_Data=31)
1286:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1287:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetSmartcardPrescaler(USART_TypeDef *USARTx)
1288:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1289:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->GTPR, USART_GTPR_PSC));
1290:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1291:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1292:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1293:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Set Smartcard Guard time value, expressed in nb of baud clocks periods
1294:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (GT[7:0] bits : Guard time value)
1295:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
1296:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Smartcard feature is supported by the USARTx instance.
1297:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll GTPR         GT            LL_USART_SetSmartcardGuardTime
1298:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1299:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  GuardTime Value between Min_Data=0x00 and Max_Data=0xFF
1300:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1301:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1302:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetSmartcardGuardTime(USART_TypeDef *USARTx, uint32_t GuardTime)
1303:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1304:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->GTPR, USART_GTPR_GT, GuardTime << USART_POSITION_GTPR_GT);
1305:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1306:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1307:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1308:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return Smartcard Guard time value, expressed in nb of baud clocks periods
1309:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (GT[7:0] bits : Guard time value)
1310:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
1311:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Smartcard feature is supported by the USARTx instance.
1312:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll GTPR         GT            LL_USART_GetSmartcardGuardTime
1313:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1314:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Smartcard Guard time value (Value between Min_Data=0x00 and Max_Data=0xFF)
1315:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1316:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetSmartcardGuardTime(USART_TypeDef *USARTx)
1317:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1318:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->GTPR, USART_GTPR_GT) >> USART_POSITION_GTPR_GT);
1319:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1320:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1321:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1322:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
1323:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1324:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1325:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EF_Configuration_HalfDuplex Configuration functions related to Half Duplex f
1326:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
1327:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1328:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1329:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1330:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable Single Wire Half-Duplex mode
1331:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_HALFDUPLEX_INSTANCE(USARTx) can be used to check whether or not
1332:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Half-Duplex mode is supported by the USARTx instance.
1333:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          HDSEL         LL_USART_EnableHalfDuplex
1334:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1335:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1336:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
ARM GAS  /tmp/ccRW1hdZ.s 			page 35


1337:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableHalfDuplex(USART_TypeDef *USARTx)
1338:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1339:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR3, USART_CR3_HDSEL);
1340:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1341:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1342:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1343:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Disable Single Wire Half-Duplex mode
1344:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_HALFDUPLEX_INSTANCE(USARTx) can be used to check whether or not
1345:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Half-Duplex mode is supported by the USARTx instance.
1346:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          HDSEL         LL_USART_DisableHalfDuplex
1347:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1348:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1349:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1350:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_DisableHalfDuplex(USART_TypeDef *USARTx)
1351:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1352:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, USART_CR3_HDSEL);
1353:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1354:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1355:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1356:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Indicate if Single Wire Half-Duplex mode is enabled
1357:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_HALFDUPLEX_INSTANCE(USARTx) can be used to check whether or not
1358:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Half-Duplex mode is supported by the USARTx instance.
1359:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          HDSEL         LL_USART_IsEnabledHalfDuplex
1360:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1361:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1362:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1363:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsEnabledHalfDuplex(USART_TypeDef *USARTx)
1364:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1365:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->CR3, USART_CR3_HDSEL) == (USART_CR3_HDSEL));
1366:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1367:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1368:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1369:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
1370:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1371:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1372:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EF_Configuration_LIN Configuration functions related to LIN feature
1373:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
1374:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1375:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1376:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1377:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Set LIN Break Detection Length
1378:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
1379:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         LIN feature is supported by the USARTx instance.
1380:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LBDL          LL_USART_SetLINBrkDetectionLen
1381:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1382:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  LINBDLength This parameter can be one of the following values:
1383:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_LINBREAK_DETECT_10B
1384:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_LINBREAK_DETECT_11B
1385:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1386:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1387:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_SetLINBrkDetectionLen(USART_TypeDef *USARTx, uint32_t LINBDLength)
1388:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1389:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   MODIFY_REG(USARTx->CR2, USART_CR2_LBDL, LINBDLength);
1390:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1391:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1392:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1393:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Return LIN Break Detection Length
ARM GAS  /tmp/ccRW1hdZ.s 			page 36


1394:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
1395:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         LIN feature is supported by the USARTx instance.
1396:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LBDL          LL_USART_GetLINBrkDetectionLen
1397:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1398:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval Returned value can be one of the following values:
1399:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_LINBREAK_DETECT_10B
1400:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         @arg @ref LL_USART_LINBREAK_DETECT_11B
1401:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1402:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_GetLINBrkDetectionLen(USART_TypeDef *USARTx)
1403:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1404:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_LBDL));
1405:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1406:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1407:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1408:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable LIN mode
1409:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
1410:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         LIN feature is supported by the USARTx instance.
1411:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LINEN         LL_USART_EnableLIN
1412:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1413:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1414:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1415:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableLIN(USART_TypeDef *USARTx)
1416:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1417:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR2, USART_CR2_LINEN);
1418:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1419:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1420:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1421:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Disable LIN mode
1422:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
1423:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         LIN feature is supported by the USARTx instance.
1424:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LINEN         LL_USART_DisableLIN
1425:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1426:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1427:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1428:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_DisableLIN(USART_TypeDef *USARTx)
1429:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1430:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR2, USART_CR2_LINEN);
1431:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1432:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1433:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1434:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Indicate if LIN mode is enabled
1435:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
1436:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         LIN feature is supported by the USARTx instance.
1437:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LINEN         LL_USART_IsEnabledLIN
1438:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1439:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1440:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1441:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsEnabledLIN(USART_TypeDef *USARTx)
1442:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1443:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->CR2, USART_CR2_LINEN) == (USART_CR2_LINEN));
1444:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1445:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1446:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1447:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
1448:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1449:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1450:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EF_AdvancedConfiguration Advanced Configurations services
ARM GAS  /tmp/ccRW1hdZ.s 			page 37


1451:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
1452:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1453:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1454:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1455:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Perform basic configuration of USART for enabling use in Asynchronous Mode (UART)
1456:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   In UART mode, the following bits must be kept cleared:
1457:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - LINEN bit in the USART_CR2 register,
1458:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - CLKEN bit in the USART_CR2 register,
1459:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - SCEN bit in the USART_CR3 register,
1460:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - IREN bit in the USART_CR3 register,
1461:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - HDSEL bit in the USART_CR3 register.
1462:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Call of this function is equivalent to following function call sequence :
1463:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear LINEN in CR2 using @ref LL_USART_DisableLIN() function
1464:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear CLKEN in CR2 using @ref LL_USART_DisableSCLKOutput() function
1465:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear SCEN in CR3 using @ref LL_USART_DisableSmartcard() function
1466:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear IREN in CR3 using @ref LL_USART_DisableIrda() function
1467:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear HDSEL in CR3 using @ref LL_USART_DisableHalfDuplex() function
1468:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Other remaining configurations items related to Asynchronous Mode
1469:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (as Baud Rate, Word length, Parity, ...) should be set using
1470:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         dedicated functions
1471:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LINEN         LL_USART_ConfigAsyncMode\n
1472:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR2          CLKEN         LL_USART_ConfigAsyncMode\n
1473:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          SCEN          LL_USART_ConfigAsyncMode\n
1474:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          IREN          LL_USART_ConfigAsyncMode\n
1475:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          HDSEL         LL_USART_ConfigAsyncMode
1476:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1477:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1478:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1479:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ConfigAsyncMode(USART_TypeDef *USARTx)
1480:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1481:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* In Asynchronous mode, the following bits must be kept cleared:
1482:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - LINEN, CLKEN bits in the USART_CR2 register,
1483:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - SCEN, IREN and HDSEL bits in the USART_CR3 register.*/
1484:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
1485:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
1486:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1487:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1488:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1489:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Perform basic configuration of USART for enabling use in Synchronous Mode
1490:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   In Synchronous mode, the following bits must be kept cleared:
1491:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - LINEN bit in the USART_CR2 register,
1492:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - SCEN bit in the USART_CR3 register,
1493:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - IREN bit in the USART_CR3 register,
1494:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - HDSEL bit in the USART_CR3 register.
1495:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         This function also sets the USART in Synchronous mode.
1496:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
1497:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Synchronous mode is supported by the USARTx instance.
1498:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Call of this function is equivalent to following function call sequence :
1499:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear LINEN in CR2 using @ref LL_USART_DisableLIN() function
1500:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear IREN in CR3 using @ref LL_USART_DisableIrda() function
1501:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear SCEN in CR3 using @ref LL_USART_DisableSmartcard() function
1502:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear HDSEL in CR3 using @ref LL_USART_DisableHalfDuplex() function
1503:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Set CLKEN in CR2 using @ref LL_USART_EnableSCLKOutput() function
1504:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Other remaining configurations items related to Synchronous Mode
1505:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (as Baud Rate, Word length, Parity, Clock Polarity, ...) should be set using
1506:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         dedicated functions
1507:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LINEN         LL_USART_ConfigSyncMode\n
ARM GAS  /tmp/ccRW1hdZ.s 			page 38


1508:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR2          CLKEN         LL_USART_ConfigSyncMode\n
1509:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          SCEN          LL_USART_ConfigSyncMode\n
1510:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          IREN          LL_USART_ConfigSyncMode\n
1511:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          HDSEL         LL_USART_ConfigSyncMode
1512:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1513:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1514:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1515:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ConfigSyncMode(USART_TypeDef *USARTx)
1516:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1517:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* In Synchronous mode, the following bits must be kept cleared:
1518:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - LINEN bit in the USART_CR2 register,
1519:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - SCEN, IREN and HDSEL bits in the USART_CR3 register.*/
1520:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN));
1521:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
1522:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* set the UART/USART in Synchronous mode */
1523:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR2, USART_CR2_CLKEN);
1524:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1525:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1526:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1527:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Perform basic configuration of USART for enabling use in LIN Mode
1528:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   In LIN mode, the following bits must be kept cleared:
1529:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - STOP and CLKEN bits in the USART_CR2 register,
1530:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - SCEN bit in the USART_CR3 register,
1531:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - IREN bit in the USART_CR3 register,
1532:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - HDSEL bit in the USART_CR3 register.
1533:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         This function also set the UART/USART in LIN mode.
1534:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
1535:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         LIN feature is supported by the USARTx instance.
1536:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Call of this function is equivalent to following function call sequence :
1537:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear CLKEN in CR2 using @ref LL_USART_DisableSCLKOutput() function
1538:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear STOP in CR2 using @ref LL_USART_SetStopBitsLength() function
1539:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear SCEN in CR3 using @ref LL_USART_DisableSmartcard() function
1540:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear IREN in CR3 using @ref LL_USART_DisableIrda() function
1541:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear HDSEL in CR3 using @ref LL_USART_DisableHalfDuplex() function
1542:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Set LINEN in CR2 using @ref LL_USART_EnableLIN() function
1543:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Other remaining configurations items related to LIN Mode
1544:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (as Baud Rate, Word length, LIN Break Detection Length, ...) should be set using
1545:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         dedicated functions
1546:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          CLKEN         LL_USART_ConfigLINMode\n
1547:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR2          STOP          LL_USART_ConfigLINMode\n
1548:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR2          LINEN         LL_USART_ConfigLINMode\n
1549:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          IREN          LL_USART_ConfigLINMode\n
1550:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          SCEN          LL_USART_ConfigLINMode\n
1551:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          HDSEL         LL_USART_ConfigLINMode
1552:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1553:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1554:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1555:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ConfigLINMode(USART_TypeDef *USARTx)
1556:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1557:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* In LIN mode, the following bits must be kept cleared:
1558:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - STOP and CLKEN bits in the USART_CR2 register,
1559:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - IREN, SCEN and HDSEL bits in the USART_CR3 register.*/
1560:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR2, (USART_CR2_CLKEN | USART_CR2_STOP));
1561:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, (USART_CR3_IREN | USART_CR3_SCEN | USART_CR3_HDSEL));
1562:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* Set the UART/USART in LIN mode */
1563:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR2, USART_CR2_LINEN);
1564:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
ARM GAS  /tmp/ccRW1hdZ.s 			page 39


1565:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1566:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1567:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Perform basic configuration of USART for enabling use in Half Duplex Mode
1568:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   In Half Duplex mode, the following bits must be kept cleared:
1569:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - LINEN bit in the USART_CR2 register,
1570:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - CLKEN bit in the USART_CR2 register,
1571:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - SCEN bit in the USART_CR3 register,
1572:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - IREN bit in the USART_CR3 register,
1573:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         This function also sets the UART/USART in Half Duplex mode.
1574:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_HALFDUPLEX_INSTANCE(USARTx) can be used to check whether or not
1575:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Half-Duplex mode is supported by the USARTx instance.
1576:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Call of this function is equivalent to following function call sequence :
1577:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear LINEN in CR2 using @ref LL_USART_DisableLIN() function
1578:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear CLKEN in CR2 using @ref LL_USART_DisableSCLKOutput() function
1579:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear SCEN in CR3 using @ref LL_USART_DisableSmartcard() function
1580:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear IREN in CR3 using @ref LL_USART_DisableIrda() function
1581:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Set HDSEL in CR3 using @ref LL_USART_EnableHalfDuplex() function
1582:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Other remaining configurations items related to Half Duplex Mode
1583:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (as Baud Rate, Word length, Parity, ...) should be set using
1584:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         dedicated functions
1585:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LINEN         LL_USART_ConfigHalfDuplexMode\n
1586:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR2          CLKEN         LL_USART_ConfigHalfDuplexMode\n
1587:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          HDSEL         LL_USART_ConfigHalfDuplexMode\n
1588:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          SCEN          LL_USART_ConfigHalfDuplexMode\n
1589:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          IREN          LL_USART_ConfigHalfDuplexMode
1590:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1591:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1592:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1593:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ConfigHalfDuplexMode(USART_TypeDef *USARTx)
1594:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1595:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* In Half Duplex mode, the following bits must be kept cleared:
1596:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - LINEN and CLKEN bits in the USART_CR2 register,
1597:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - SCEN and IREN bits in the USART_CR3 register.*/
1598:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
1599:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN));
1600:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* set the UART/USART in Half Duplex mode */
1601:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR3, USART_CR3_HDSEL);
1602:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1603:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1604:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1605:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Perform basic configuration of USART for enabling use in Smartcard Mode
1606:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   In Smartcard mode, the following bits must be kept cleared:
1607:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - LINEN bit in the USART_CR2 register,
1608:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - IREN bit in the USART_CR3 register,
1609:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - HDSEL bit in the USART_CR3 register.
1610:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         This function also configures Stop bits to 1.5 bits and
1611:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         sets the USART in Smartcard mode (SCEN bit).
1612:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Clock Output is also enabled (CLKEN).
1613:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_SMARTCARD_INSTANCE(USARTx) can be used to check whether or not
1614:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Smartcard feature is supported by the USARTx instance.
1615:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Call of this function is equivalent to following function call sequence :
1616:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear LINEN in CR2 using @ref LL_USART_DisableLIN() function
1617:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear IREN in CR3 using @ref LL_USART_DisableIrda() function
1618:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear HDSEL in CR3 using @ref LL_USART_DisableHalfDuplex() function
1619:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Configure STOP in CR2 using @ref LL_USART_SetStopBitsLength() function
1620:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Set CLKEN in CR2 using @ref LL_USART_EnableSCLKOutput() function
1621:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Set SCEN in CR3 using @ref LL_USART_EnableSmartcard() function
ARM GAS  /tmp/ccRW1hdZ.s 			page 40


1622:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Other remaining configurations items related to Smartcard Mode
1623:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (as Baud Rate, Word length, Parity, ...) should be set using
1624:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         dedicated functions
1625:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LINEN         LL_USART_ConfigSmartcardMode\n
1626:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR2          STOP          LL_USART_ConfigSmartcardMode\n
1627:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR2          CLKEN         LL_USART_ConfigSmartcardMode\n
1628:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          HDSEL         LL_USART_ConfigSmartcardMode\n
1629:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          SCEN          LL_USART_ConfigSmartcardMode
1630:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1631:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1632:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1633:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ConfigSmartcardMode(USART_TypeDef *USARTx)
1634:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1635:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* In Smartcard mode, the following bits must be kept cleared:
1636:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - LINEN bit in the USART_CR2 register,
1637:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - IREN and HDSEL bits in the USART_CR3 register.*/
1638:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN));
1639:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, (USART_CR3_IREN | USART_CR3_HDSEL));
1640:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* Configure Stop bits to 1.5 bits */
1641:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* Synchronous mode is activated by default */
1642:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR2, (USART_CR2_STOP_0 | USART_CR2_STOP_1 | USART_CR2_CLKEN));
1643:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* set the UART/USART in Smartcard mode */
1644:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR3, USART_CR3_SCEN);
1645:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1646:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1647:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1648:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Perform basic configuration of USART for enabling use in Irda Mode
1649:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   In IRDA mode, the following bits must be kept cleared:
1650:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - LINEN bit in the USART_CR2 register,
1651:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - STOP and CLKEN bits in the USART_CR2 register,
1652:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - SCEN bit in the USART_CR3 register,
1653:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - HDSEL bit in the USART_CR3 register.
1654:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         This function also sets the UART/USART in IRDA mode (IREN bit).
1655:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_IRDA_INSTANCE(USARTx) can be used to check whether or not
1656:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         IrDA feature is supported by the USARTx instance.
1657:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Call of this function is equivalent to following function call sequence :
1658:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear LINEN in CR2 using @ref LL_USART_DisableLIN() function
1659:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear CLKEN in CR2 using @ref LL_USART_DisableSCLKOutput() function
1660:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear SCEN in CR3 using @ref LL_USART_DisableSmartcard() function
1661:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear HDSEL in CR3 using @ref LL_USART_DisableHalfDuplex() function
1662:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Configure STOP in CR2 using @ref LL_USART_SetStopBitsLength() function
1663:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Set IREN in CR3 using @ref LL_USART_EnableIrda() function
1664:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Other remaining configurations items related to Irda Mode
1665:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (as Baud Rate, Word length, Power mode, ...) should be set using
1666:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         dedicated functions
1667:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LINEN         LL_USART_ConfigIrdaMode\n
1668:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR2          CLKEN         LL_USART_ConfigIrdaMode\n
1669:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR2          STOP          LL_USART_ConfigIrdaMode\n
1670:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          SCEN          LL_USART_ConfigIrdaMode\n
1671:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          HDSEL         LL_USART_ConfigIrdaMode\n
1672:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          IREN          LL_USART_ConfigIrdaMode
1673:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1674:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1675:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1676:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ConfigIrdaMode(USART_TypeDef *USARTx)
1677:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1678:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* In IRDA mode, the following bits must be kept cleared:
ARM GAS  /tmp/ccRW1hdZ.s 			page 41


1679:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - LINEN, STOP and CLKEN bits in the USART_CR2 register,
1680:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - SCEN and HDSEL bits in the USART_CR3 register.*/
1681:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN | USART_CR2_STOP));
1682:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL));
1683:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* set the UART/USART in IRDA mode */
1684:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR3, USART_CR3_IREN);
1685:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1686:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1687:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1688:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Perform basic configuration of USART for enabling use in Multi processor Mode
1689:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (several USARTs connected in a network, one of the USARTs can be the master,
1690:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         its TX output connected to the RX inputs of the other slaves USARTs).
1691:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   In MultiProcessor mode, the following bits must be kept cleared:
1692:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - LINEN bit in the USART_CR2 register,
1693:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - CLKEN bit in the USART_CR2 register,
1694:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - SCEN bit in the USART_CR3 register,
1695:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - IREN bit in the USART_CR3 register,
1696:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           - HDSEL bit in the USART_CR3 register.
1697:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Call of this function is equivalent to following function call sequence :
1698:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear LINEN in CR2 using @ref LL_USART_DisableLIN() function
1699:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear CLKEN in CR2 using @ref LL_USART_DisableSCLKOutput() function
1700:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear SCEN in CR3 using @ref LL_USART_DisableSmartcard() function
1701:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear IREN in CR3 using @ref LL_USART_DisableIrda() function
1702:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         - Clear HDSEL in CR3 using @ref LL_USART_DisableHalfDuplex() function
1703:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Other remaining configurations items related to Multi processor Mode
1704:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         (as Baud Rate, Wake Up Method, Node address, ...) should be set using
1705:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         dedicated functions
1706:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LINEN         LL_USART_ConfigMultiProcessMode\n
1707:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR2          CLKEN         LL_USART_ConfigMultiProcessMode\n
1708:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          SCEN          LL_USART_ConfigMultiProcessMode\n
1709:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          HDSEL         LL_USART_ConfigMultiProcessMode\n
1710:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         CR3          IREN          LL_USART_ConfigMultiProcessMode
1711:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1712:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1713:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1714:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ConfigMultiProcessMode(USART_TypeDef *USARTx)
1715:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1716:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   /* In Multi Processor mode, the following bits must be kept cleared:
1717:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - LINEN and CLKEN bits in the USART_CR2 register,
1718:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   - IREN, SCEN and HDSEL bits in the USART_CR3 register.*/
1719:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
1720:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
1721:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1722:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1723:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1724:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
1725:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1726:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1727:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EF_FLAG_Management FLAG_Management
1728:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
1729:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1730:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1731:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1732:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Check if the USART Parity Error Flag is set or not
1733:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           PE            LL_USART_IsActiveFlag_PE
1734:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1735:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
ARM GAS  /tmp/ccRW1hdZ.s 			page 42


1736:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1737:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_PE(USART_TypeDef *USARTx)
1738:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1739:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->SR, USART_SR_PE) == (USART_SR_PE));
1740:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1741:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1742:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1743:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Check if the USART Framing Error Flag is set or not
1744:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           FE            LL_USART_IsActiveFlag_FE
1745:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1746:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1747:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1748:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_FE(USART_TypeDef *USARTx)
1749:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1750:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->SR, USART_SR_FE) == (USART_SR_FE));
1751:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1752:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1753:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1754:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Check if the USART Noise error detected Flag is set or not
1755:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           NF            LL_USART_IsActiveFlag_NE
1756:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1757:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1758:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1759:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_NE(USART_TypeDef *USARTx)
1760:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1761:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->SR, USART_SR_NE) == (USART_SR_NE));
1762:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1763:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1764:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1765:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Check if the USART OverRun Error Flag is set or not
1766:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           ORE           LL_USART_IsActiveFlag_ORE
1767:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1768:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1769:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1770:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_ORE(USART_TypeDef *USARTx)
1771:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1772:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->SR, USART_SR_ORE) == (USART_SR_ORE));
1773:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1774:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1775:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1776:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Check if the USART IDLE line detected Flag is set or not
1777:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           IDLE          LL_USART_IsActiveFlag_IDLE
1778:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1779:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1780:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1781:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_IDLE(USART_TypeDef *USARTx)
1782:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1783:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->SR, USART_SR_IDLE) == (USART_SR_IDLE));
1784:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1785:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1786:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1787:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Check if the USART Read Data Register Not Empty Flag is set or not
1788:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           RXNE          LL_USART_IsActiveFlag_RXNE
1789:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1790:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1791:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1792:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_RXNE(USART_TypeDef *USARTx)
ARM GAS  /tmp/ccRW1hdZ.s 			page 43


1793:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1794:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
1795:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1796:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1797:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1798:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Check if the USART Transmission Complete Flag is set or not
1799:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           TC            LL_USART_IsActiveFlag_TC
1800:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1801:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1802:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1803:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TC(USART_TypeDef *USARTx)
1804:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1805:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->SR, USART_SR_TC) == (USART_SR_TC));
1806:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1807:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1808:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1809:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Check if the USART Transmit Data Register Empty Flag is set or not
1810:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           TXE           LL_USART_IsActiveFlag_TXE
1811:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1812:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1813:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1814:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TXE(USART_TypeDef *USARTx)
1815:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1816:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->SR, USART_SR_TXE) == (USART_SR_TXE));
1817:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1818:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1819:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1820:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Check if the USART LIN Break Detection Flag is set or not
1821:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
1822:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         LIN feature is supported by the USARTx instance.
1823:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           LBD           LL_USART_IsActiveFlag_LBD
1824:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1825:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1826:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1827:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_LBD(USART_TypeDef *USARTx)
1828:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1829:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->SR, USART_SR_LBD) == (USART_SR_LBD));
1830:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1831:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1832:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1833:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Check if the USART CTS Flag is set or not
1834:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
1835:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Hardware Flow control feature is supported by the USARTx instance.
1836:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           CTS           LL_USART_IsActiveFlag_nCTS
1837:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1838:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1839:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1840:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_nCTS(USART_TypeDef *USARTx)
1841:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1842:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->SR, USART_SR_CTS) == (USART_SR_CTS));
1843:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1844:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1845:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1846:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Check if the USART Send Break Flag is set or not
1847:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          SBK           LL_USART_IsActiveFlag_SBK
1848:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1849:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
ARM GAS  /tmp/ccRW1hdZ.s 			page 44


1850:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1851:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_SBK(USART_TypeDef *USARTx)
1852:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1853:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->CR1, USART_CR1_SBK) == (USART_CR1_SBK));
1854:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1855:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1856:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1857:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Check if the USART Receive Wake Up from mute mode Flag is set or not
1858:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          RWU           LL_USART_IsActiveFlag_RWU
1859:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1860:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval State of bit (1 or 0).
1861:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1862:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_RWU(USART_TypeDef *USARTx)
1863:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1864:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   return (READ_BIT(USARTx->CR1, USART_CR1_RWU) == (USART_CR1_RWU));
1865:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1866:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1867:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1868:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Clear Parity Error Flag
1869:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Clearing this flag is done by a read access to the USARTx_SR
1870:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         register followed by a read access to the USARTx_DR register.
1871:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Please also consider that when clearing this flag, other flags as
1872:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         NE, FE, ORE, IDLE would also be cleared.
1873:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           PE            LL_USART_ClearFlag_PE
1874:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1875:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1876:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1877:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ClearFlag_PE(USART_TypeDef *USARTx)
1878:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1879:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   __IO uint32_t tmpreg;
1880:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   tmpreg = USARTx->SR;
1881:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   (void) tmpreg;
1882:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   tmpreg = USARTx->DR;
1883:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   (void) tmpreg;
1884:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1885:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1886:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1887:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Clear Framing Error Flag
1888:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Clearing this flag is done by a read access to the USARTx_SR
1889:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         register followed by a read access to the USARTx_DR register.
1890:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Please also consider that when clearing this flag, other flags as
1891:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         PE, NE, ORE, IDLE would also be cleared.
1892:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           FE            LL_USART_ClearFlag_FE
1893:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1894:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1895:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1896:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ClearFlag_FE(USART_TypeDef *USARTx)
1897:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1898:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   __IO uint32_t tmpreg;
1899:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   tmpreg = USARTx->SR;
1900:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   (void) tmpreg;
1901:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   tmpreg = USARTx->DR;
1902:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   (void) tmpreg;
1903:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1904:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1905:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1906:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Clear Noise detected Flag
ARM GAS  /tmp/ccRW1hdZ.s 			page 45


1907:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Clearing this flag is done by a read access to the USARTx_SR
1908:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         register followed by a read access to the USARTx_DR register.
1909:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Please also consider that when clearing this flag, other flags as
1910:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         PE, FE, ORE, IDLE would also be cleared.
1911:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           NF            LL_USART_ClearFlag_NE
1912:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1913:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1914:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1915:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ClearFlag_NE(USART_TypeDef *USARTx)
1916:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1917:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   __IO uint32_t tmpreg;
1918:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   tmpreg = USARTx->SR;
1919:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   (void) tmpreg;
1920:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   tmpreg = USARTx->DR;
1921:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   (void) tmpreg;
1922:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1923:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1924:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1925:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Clear OverRun Error Flag
1926:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Clearing this flag is done by a read access to the USARTx_SR
1927:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         register followed by a read access to the USARTx_DR register.
1928:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Please also consider that when clearing this flag, other flags as
1929:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         PE, NE, FE, IDLE would also be cleared.
1930:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           ORE           LL_USART_ClearFlag_ORE
1931:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1932:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1933:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1934:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ClearFlag_ORE(USART_TypeDef *USARTx)
1935:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1936:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   __IO uint32_t tmpreg;
1937:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   tmpreg = USARTx->SR;
1938:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   (void) tmpreg;
1939:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   tmpreg = USARTx->DR;
1940:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   (void) tmpreg;
1941:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1942:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1943:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1944:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Clear IDLE line detected Flag
1945:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Clearing this flag is done by a read access to the USARTx_SR
1946:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         register followed by a read access to the USARTx_DR register.
1947:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Please also consider that when clearing this flag, other flags as
1948:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         PE, NE, FE, ORE would also be cleared.
1949:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           IDLE          LL_USART_ClearFlag_IDLE
1950:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1951:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1952:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1953:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ClearFlag_IDLE(USART_TypeDef *USARTx)
1954:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1955:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   __IO uint32_t tmpreg;
1956:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   tmpreg = USARTx->SR;
1957:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   (void) tmpreg;
1958:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   tmpreg = USARTx->DR;
1959:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   (void) tmpreg;
1960:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1961:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1962:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1963:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Clear Transmission Complete Flag
ARM GAS  /tmp/ccRW1hdZ.s 			page 46


1964:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           TC            LL_USART_ClearFlag_TC
1965:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1966:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1967:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1968:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ClearFlag_TC(USART_TypeDef *USARTx)
1969:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1970:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   WRITE_REG(USARTx->SR, ~(USART_SR_TC));
1971:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1972:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1973:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1974:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Clear RX Not Empty Flag
1975:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           RXNE          LL_USART_ClearFlag_RXNE
1976:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1977:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1978:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1979:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ClearFlag_RXNE(USART_TypeDef *USARTx)
1980:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1981:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   WRITE_REG(USARTx->SR, ~(USART_SR_RXNE));
1982:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1983:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1984:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1985:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Clear LIN Break Detection Flag
1986:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
1987:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         LIN feature is supported by the USARTx instance.
1988:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           LBD           LL_USART_ClearFlag_LBD
1989:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
1990:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
1991:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
1992:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ClearFlag_LBD(USART_TypeDef *USARTx)
1993:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
1994:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   WRITE_REG(USARTx->SR, ~(USART_SR_LBD));
1995:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
1996:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
1997:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
1998:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Clear CTS Interrupt Flag
1999:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
2000:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Hardware Flow control feature is supported by the USARTx instance.
2001:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll SR           CTS           LL_USART_ClearFlag_nCTS
2002:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
2003:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
2004:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
2005:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_ClearFlag_nCTS(USART_TypeDef *USARTx)
2006:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
2007:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   WRITE_REG(USARTx->SR, ~(USART_SR_CTS));
2008:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
2009:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
2010:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
2011:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @}
2012:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
2013:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
2014:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /** @defgroup USART_LL_EF_IT_Management IT_Management
2015:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @{
2016:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
2017:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
2018:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
2019:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable IDLE Interrupt
2020:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          IDLEIE        LL_USART_EnableIT_IDLE
ARM GAS  /tmp/ccRW1hdZ.s 			page 47


2021:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
2022:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
2023:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
2024:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableIT_IDLE(USART_TypeDef *USARTx)
2025:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
2026:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
2027:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
2028:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
2029:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
2030:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable RX Not Empty Interrupt
2031:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          RXNEIE        LL_USART_EnableIT_RXNE
2032:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
2033:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
2034:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
2035:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableIT_RXNE(USART_TypeDef *USARTx)
2036:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
2037:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
2038:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
2039:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
2040:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
2041:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable Transmission Complete Interrupt
2042:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          TCIE          LL_USART_EnableIT_TC
2043:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
2044:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
2045:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
2046:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableIT_TC(USART_TypeDef *USARTx)
2047:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
2048:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
2049:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
2050:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
2051:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
2052:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable TX Empty Interrupt
2053:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          TXEIE         LL_USART_EnableIT_TXE
2054:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
2055:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
2056:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
2057:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableIT_TXE(USART_TypeDef *USARTx)
2058:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
2059:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TXEIE);
2060:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
2061:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
2062:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
2063:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable Parity Error Interrupt
2064:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          PEIE          LL_USART_EnableIT_PE
2065:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
2066:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
2067:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
2068:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableIT_PE(USART_TypeDef *USARTx)
2069:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
2070:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
2071:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
2072:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
2073:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
2074:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable LIN Break Detection Interrupt
2075:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
2076:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         LIN feature is supported by the USARTx instance.
2077:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR2          LBDIE         LL_USART_EnableIT_LBD
ARM GAS  /tmp/ccRW1hdZ.s 			page 48


2078:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
2079:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
2080:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
2081:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableIT_LBD(USART_TypeDef *USARTx)
2082:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
2083:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   SET_BIT(USARTx->CR2, USART_CR2_LBDIE);
2084:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
2085:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
2086:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
2087:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable Error Interrupt
2088:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   When set, Error Interrupt Enable Bit is enabling interrupt generation in case of a fram
2089:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         error, overrun error or noise flag (FE=1 or ORE=1 or NF=1 in the USARTx_SR register).
2090:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           0: Interrupt is inhibited
2091:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *           1: An interrupt is generated when FE=1 or ORE=1 or NF=1 in the USARTx_SR register.
2092:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          EIE           LL_USART_EnableIT_ERROR
2093:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
2094:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
2095:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
2096:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableIT_ERROR(USART_TypeDef *USARTx)
2097:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
2098:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
2099:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
2100:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
2101:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
2102:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Enable CTS Interrupt
2103:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
2104:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   *         Hardware Flow control feature is supported by the USARTx instance.
2105:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR3          CTSIE         LL_USART_EnableIT_CTS
2106:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
2107:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
2108:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
2109:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_EnableIT_CTS(USART_TypeDef *USARTx)
2110:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
2111:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_CTSIE);
2112:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
2113:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
2114:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
2115:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Disable IDLE Interrupt
2116:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          IDLEIE        LL_USART_DisableIT_IDLE
2117:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
2118:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
2119:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
2120:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_DisableIT_IDLE(USART_TypeDef *USARTx)
2121:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
2122:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
2123:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
2124:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** 
2125:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** /**
2126:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @brief  Disable RX Not Empty Interrupt
2127:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @rmtoll CR1          RXNEIE        LL_USART_DisableIT_RXNE
2128:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @param  USARTx USART Instance
2129:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   * @retval None
2130:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   */
2131:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** __STATIC_INLINE void LL_USART_DisableIT_RXNE(USART_TypeDef *USARTx)
2132:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
2133:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h ****   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 420              		.loc 2 2133 3 is_stmt 1 view .LVU75
ARM GAS  /tmp/ccRW1hdZ.s 			page 49


 421              	.LBB26:
 422              	.LBB27:
 423              		.loc 2 2133 3 view .LVU76
 424              		.loc 2 2133 3 view .LVU77
 425              		.loc 2 2133 3 view .LVU78
 426 000e 274C     		ldr	r4, .L28+4
 427              	.LVL32:
 428              	.LBB28:
 429              	.LBI28:
 430              		.file 3 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  25:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
ARM GAS  /tmp/ccRW1hdZ.s 			page 50


  48:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  49:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  55:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  67:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  78:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 102:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
ARM GAS  /tmp/ccRW1hdZ.s 			page 51


 105:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 110:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 116:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 117:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 118:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 122:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 123:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 124:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 125:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 129:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 131:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 133:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 134:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 135:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 140:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 142:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 144:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 145:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 146:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 151:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 153:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 155:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 158:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 159:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 160:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/ccRW1hdZ.s 			page 52


 162:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 168:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 170:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 175:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 176:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 177:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 181:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 183:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 186:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 187:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 189:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 193:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 197:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 201:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 205:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 207:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 212:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 213:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 214:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 215:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccRW1hdZ.s 			page 53


 219:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 221:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 223:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 226:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 227:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 228:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 229:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 233:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 235:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 237:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 240:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 241:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 242:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 243:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 247:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 249:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 251:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 254:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 255:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 256:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 258:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 262:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 264:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 266:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 269:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 270:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 271:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 272:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 273:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
ARM GAS  /tmp/ccRW1hdZ.s 			page 54


 276:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 277:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 279:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 281:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 282:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 283:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 285:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 289:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 291:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 293:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 294:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 295:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 296:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 297:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 301:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 303:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 305:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 308:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 309:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 310:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 312:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 316:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 318:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 320:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 323:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 324:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 325:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 326:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 327:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 331:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:Drivers/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  /tmp/ccRW1hdZ.s 			page 55


 333:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 335:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 336:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 337:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 339:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 343:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 345:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 347:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 348:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 349:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 350:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 352:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 356:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 358:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 360:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 363:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 364:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 365:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 366:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 370:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 372:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 374:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 375:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 376:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 377:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 378:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 382:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 384:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 385:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 386:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 388:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 389:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccRW1hdZ.s 			page 56


 390:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 391:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 393:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 397:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 399:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 401:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 404:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 405:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 406:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 407:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 408:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 412:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 414:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 416:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 417:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 418:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 420:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 424:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 426:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 428:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 429:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 430:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 431:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 435:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 436:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 439:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 441:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 443:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 444:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 445:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 446:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
ARM GAS  /tmp/ccRW1hdZ.s 			page 57


 447:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 450:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 452:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 454:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 455:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 456:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 457:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 458:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 460:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 461:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 463:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 464:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 465:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 467:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 468:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 469:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 470:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 472:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 475:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 476:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 478:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 479:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 480:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 482:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 483:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 484:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 485:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 486:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 487:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 488:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 491:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 493:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 495:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 496:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 497:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 499:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 503:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
ARM GAS  /tmp/ccRW1hdZ.s 			page 58


 504:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 505:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 507:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 508:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 509:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 510:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 511:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:Drivers/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 516:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 518:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 520:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 521:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 522:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 523:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 526:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 527:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 529:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 530:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 531:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 533:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 534:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 535:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 536:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 538:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 541:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 542:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 544:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 545:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 546:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 548:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 549:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 550:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 551:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 552:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 553:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 557:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 559:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:Drivers/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/ccRW1hdZ.s 			page 59


 561:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 562:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 563:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 565:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 569:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 571:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 573:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 574:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 575:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 579:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 580:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 583:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 584:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 588:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 589:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 592:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 594:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:Drivers/CMSIS/Include/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 598:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 599:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 600:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 601:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 602:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 603:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 604:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 605:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 607:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 608:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 609:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 611:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 614:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 615:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 616:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
ARM GAS  /tmp/ccRW1hdZ.s 			page 60


 618:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 619:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 620:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 621:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 623:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 624:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 625:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 626:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 627:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 628:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 629:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 632:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 633:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 634:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 637:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 639:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 644:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 646:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 647:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 648:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 649:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 651:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 655:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 657:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 658:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 659:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 660:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 662:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 664:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 665:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 666:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 667:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 668:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 669:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 670:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 671:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 672:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
ARM GAS  /tmp/ccRW1hdZ.s 			page 61


 675:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 676:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 679:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 681:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 684:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 685:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 686:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 687:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 689:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 690:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 691:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 692:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 693:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 694:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 695:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 696:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 699:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 702:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 704:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 707:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 708:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 709:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 711:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 712:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 713:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 714:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 715:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 716:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 717:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 719:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 721:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 722:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 723:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 725:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 727:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 728:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 729:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
ARM GAS  /tmp/ccRW1hdZ.s 			page 62


 732:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 734:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 735:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 736:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 737:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 739:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 741:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 743:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 746:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 748:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 751:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 752:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 753:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 754:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 755:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 756:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 757:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 760:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 761:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 762:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 763:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 766:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 768:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:Drivers/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 771:Drivers/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 772:Drivers/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 773:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 774:Drivers/CMSIS/Include/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 776:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 777:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 778:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 779:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 780:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 781:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 782:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(0U);
 783:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 784:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 785:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 786:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 787:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 788:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
ARM GAS  /tmp/ccRW1hdZ.s 			page 63


 789:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 792:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 794:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:Drivers/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:Drivers/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 798:Drivers/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:Drivers/CMSIS/Include/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 802:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 803:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 804:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 805:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 806:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 807:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 808:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 809:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 810:Drivers/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 812:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 813:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:Drivers/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 816:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 817:Drivers/CMSIS/Include/cmsis_gcc.h **** */
 818:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 819:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:Drivers/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 827:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 828:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 829:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 830:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 831:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 832:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 833:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 834:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 836:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 837:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 838:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 839:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 842:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 843:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 844:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 845:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/ccRW1hdZ.s 			page 64


 846:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 847:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:Drivers/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 850:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 852:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 853:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 854:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 855:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 857:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 859:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 860:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 861:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:Drivers/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:Drivers/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 865:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 866:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 867:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 868:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 870:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 871:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 872:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 873:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:Drivers/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 877:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 878:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 879:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 880:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 881:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 882:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 883:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 884:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 885:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 886:Drivers/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 887:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 888:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 889:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 890:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 891:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 892:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 893:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 894:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 895:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 896:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 897:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 898:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 899:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 900:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 901:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 902:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
ARM GAS  /tmp/ccRW1hdZ.s 			page 65


 903:Drivers/CMSIS/Include/cmsis_gcc.h ****   return __builtin_bswap32(value);
 904:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 905:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 906:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 907:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 908:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 909:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 910:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 911:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 912:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 913:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 914:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 915:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 916:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 917:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 918:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 919:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 920:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 921:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 922:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 923:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 924:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 925:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 926:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 927:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 928:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 929:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 930:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 931:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 932:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 933:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 934:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 935:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 936:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 937:Drivers/CMSIS/Include/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 938:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 939:Drivers/CMSIS/Include/cmsis_gcc.h ****   int16_t result;
 940:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 941:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 942:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 943:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 944:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 945:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 946:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 947:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 948:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Rotate Right in unsigned value (32 bit)
 949:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Rotate Right (immediate) provides the value of the contents of a register rotated by a v
 950:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op1  Value to rotate
 951:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op2  Number of Bits to rotate
 952:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Rotated value
 953:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 954:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
 955:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 956:Drivers/CMSIS/Include/cmsis_gcc.h ****   op2 %= 32U;
 957:Drivers/CMSIS/Include/cmsis_gcc.h ****   if (op2 == 0U)
 958:Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 959:Drivers/CMSIS/Include/cmsis_gcc.h ****     return op1;
ARM GAS  /tmp/ccRW1hdZ.s 			page 66


 960:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 961:Drivers/CMSIS/Include/cmsis_gcc.h ****   return (op1 >> op2) | (op1 << (32U - op2));
 962:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 963:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 964:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 965:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 966:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Breakpoint
 967:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Causes the processor to enter Debug state.
 968:Drivers/CMSIS/Include/cmsis_gcc.h ****            Debug tools can use this to investigate system state when the instruction at a particula
 969:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  is ignored by the processor.
 970:Drivers/CMSIS/Include/cmsis_gcc.h ****                  If required, a debugger can use it to store additional information about the break
 971:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 972:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
 973:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 974:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 975:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 976:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse bit order of value
 977:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the bit order of the given value.
 978:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 979:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 980:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 981:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)
 982:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 983:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 984:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 985:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 986:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 987:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 988:Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 989:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 990:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
 991:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 992:Drivers/CMSIS/Include/cmsis_gcc.h ****   result = value;                      /* r will be reversed bits of v; first get LSB of v */
 993:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (value >>= 1U; value != 0U; value >>= 1U)
 994:Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 995:Drivers/CMSIS/Include/cmsis_gcc.h ****     result <<= 1U;
 996:Drivers/CMSIS/Include/cmsis_gcc.h ****     result |= value & 1U;
 997:Drivers/CMSIS/Include/cmsis_gcc.h ****     s--;
 998:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 999:Drivers/CMSIS/Include/cmsis_gcc.h ****   result <<= s;                        /* shift when v's highest bits are zero */
1000:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
1001:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
1002:Drivers/CMSIS/Include/cmsis_gcc.h **** }
1003:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1004:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1005:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
1006:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Count leading zeros
1007:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Counts the number of leading zeros of a data value.
1008:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to count the leading zeros
1009:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             number of leading zeros in value
1010:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
1011:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CLZ             (uint8_t)__builtin_clz
1012:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1013:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1014:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
1015:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
1016:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
ARM GAS  /tmp/ccRW1hdZ.s 			page 67


1017:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
1018:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
1019:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDR Exclusive (8 bit)
1020:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive LDR instruction for 8 bit value.
1021:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
1022:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             value of type uint8_t at (*ptr)
1023:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
1024:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint8_t __LDREXB(volatile uint8_t *addr)
1025:Drivers/CMSIS/Include/cmsis_gcc.h **** {
1026:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
1027:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1028:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
1029:Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
1030:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
1031:Drivers/CMSIS/Include/cmsis_gcc.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
1032:Drivers/CMSIS/Include/cmsis_gcc.h ****        accepted by assembler. So has to use following less efficient pattern.
1033:Drivers/CMSIS/Include/cmsis_gcc.h ****     */
1034:Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
1035:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
1036:Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint8_t) result);    /* Add explicit type cast here */
1037:Drivers/CMSIS/Include/cmsis_gcc.h **** }
1038:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1039:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1040:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
1041:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDR Exclusive (16 bit)
1042:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive LDR instruction for 16 bit values.
1043:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
1044:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint16_t at (*ptr)
1045:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
1046:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint16_t __LDREXH(volatile uint16_t *addr)
1047:Drivers/CMSIS/Include/cmsis_gcc.h **** {
1048:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
1049:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1050:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
1051:Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
1052:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
1053:Drivers/CMSIS/Include/cmsis_gcc.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
1054:Drivers/CMSIS/Include/cmsis_gcc.h ****        accepted by assembler. So has to use following less efficient pattern.
1055:Drivers/CMSIS/Include/cmsis_gcc.h ****     */
1056:Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
1057:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
1058:Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint16_t) result);    /* Add explicit type cast here */
1059:Drivers/CMSIS/Include/cmsis_gcc.h **** }
1060:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1061:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1062:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
1063:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDR Exclusive (32 bit)
1064:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive LDR instruction for 32 bit values.
1065:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
1066:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint32_t at (*ptr)
1067:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
1068:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
 431              		.loc 3 1068 31 view .LVU79
 432              	.LBB29:
1069:Drivers/CMSIS/Include/cmsis_gcc.h **** {
1070:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 433              		.loc 3 1070 5 view .LVU80
ARM GAS  /tmp/ccRW1hdZ.s 			page 68


1071:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1072:Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 434              		.loc 3 1072 4 view .LVU81
 435              		.syntax unified
 436              	@ 1072 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 437 0010 54E8003F 		ldrex r3, [r4]
 438              	@ 0 "" 2
 439              	.LVL33:
1073:Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 440              		.loc 3 1073 4 view .LVU82
 441              		.loc 3 1073 4 is_stmt 0 view .LVU83
 442              		.thumb
 443              		.syntax unified
 444              	.LBE29:
 445              	.LBE28:
 446              		.loc 2 2133 3 view .LVU84
 447 0014 23F02003 		bic	r3, r3, #32
 448              	.LVL34:
 449              		.loc 2 2133 3 is_stmt 1 view .LVU85
 450              	.LBB30:
 451              	.LBI30:
1074:Drivers/CMSIS/Include/cmsis_gcc.h **** }
1075:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1076:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1077:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
1078:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STR Exclusive (8 bit)
1079:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive STR instruction for 8 bit values.
1080:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
1081:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
1082:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
1083:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
1084:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
1085:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
1086:Drivers/CMSIS/Include/cmsis_gcc.h **** {
1087:Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
1088:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1089:Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
1090:Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
1091:Drivers/CMSIS/Include/cmsis_gcc.h **** }
1092:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1093:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1094:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
1095:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STR Exclusive (16 bit)
1096:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive STR instruction for 16 bit values.
1097:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
1098:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
1099:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
1100:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
1101:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
1102:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
1103:Drivers/CMSIS/Include/cmsis_gcc.h **** {
1104:Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
1105:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1106:Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
1107:Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
1108:Drivers/CMSIS/Include/cmsis_gcc.h **** }
1109:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccRW1hdZ.s 			page 69


1110:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1111:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
1112:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STR Exclusive (32 bit)
1113:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive STR instruction for 32 bit values.
1114:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
1115:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
1116:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
1117:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
1118:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
1119:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
 452              		.loc 3 1119 31 view .LVU86
 453              	.LBB31:
1120:Drivers/CMSIS/Include/cmsis_gcc.h **** {
1121:Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
 454              		.loc 3 1121 4 view .LVU87
1122:Drivers/CMSIS/Include/cmsis_gcc.h **** 
1123:Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 455              		.loc 3 1123 4 view .LVU88
 456              		.syntax unified
 457              	@ 1123 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 458 0018 44E80032 		strex r2, r3, [r4]
 459              	@ 0 "" 2
 460              	.LVL35:
1124:Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 461              		.loc 3 1124 4 view .LVU89
 462              		.loc 3 1124 4 is_stmt 0 view .LVU90
 463              		.thumb
 464              		.syntax unified
 465              	.LBE31:
 466              	.LBE30:
 467              		.loc 2 2133 3 view .LVU91
 468 001c 002A     		cmp	r2, #0
 469 001e F6D1     		bne	.L17
 470              	.LBE27:
 471              	.LBE26:
 472              		.loc 2 2133 3 is_stmt 1 view .LVU92
 473              	.LVL36:
 102:./Hardware/ESP8266/bsp_esp8266_test.c ****   {
 103:./Hardware/ESP8266/bsp_esp8266_test.c ****       LL_USART_DisableIT_RXNE(macESP8266_USARTx);
 104:./Hardware/ESP8266/bsp_esp8266_test.c ****       strEsp8266_Fram_Record .Data_RX_BUF [ strEsp8266_Fram_Record .InfBit .FramLength ]  = '\0';
 474              		.loc 1 104 7 view .LVU93
 475              		.loc 1 104 76 is_stmt 0 view .LVU94
 476 0020 214D     		ldr	r5, .L28
 477 0022 B5F80034 		ldrh	r3, [r5, #1024]
 478 0026 C3F30E03 		ubfx	r3, r3, #0, #15
 479              		.loc 1 104 91 view .LVU95
 480 002a 0026     		movs	r6, #0
 481 002c EE54     		strb	r6, [r5, r3]
 105:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 106:./Hardware/ESP8266/bsp_esp8266_test.c ****       //‰ΩøÁî®USART1Â∞Üesp8266Êé•Êî∂Âà∞ÁöÑÊï∞ÊçÆÈÄöËøá‰∏≤Âè£Ë∞ÉËØïÂä©ÊâãÊâìÂç∞Âá∫Êù•
 107:./Hardware/ESP8266/bsp_esp8266_test.c ****       //printf("%s\n",strEsp8266_Fram_Record.Data_RX_BUF);
 108:./Hardware/ESP8266/bsp_esp8266_test.c **** 
 109:./Hardware/ESP8266/bsp_esp8266_test.c ****       //Ëß£ÊûêÊï∞ÊçÆÂêéÔºåÊâßË°åÁöÑÊìç‰ΩúÂáΩÊï∞Âú®ËøôÈáåË∞ÉÁî®
 110:./Hardware/ESP8266/bsp_esp8266_test.c ****       analytical_data();
 482              		.loc 1 110 7 is_stmt 1 view .LVU96
 483 002e FFF7FEFF 		bl	analytical_data
 484              	.LVL37:
ARM GAS  /tmp/ccRW1hdZ.s 			page 70


 111:./Hardware/ESP8266/bsp_esp8266_test.c **** 
 112:./Hardware/ESP8266/bsp_esp8266_test.c ****       strEsp8266_Fram_Record .InfBit .FramLength = 0;                             //Êé•Êî∂Êï∞ÊçÆÈïø
 485              		.loc 1 112 7 view .LVU97
 486              		.loc 1 112 50 is_stmt 0 view .LVU98
 487 0032 B5F80034 		ldrh	r3, [r5, #1024]
 488 0036 66F30E03 		bfi	r3, r6, #0, #15
 489 003a A5F80034 		strh	r3, [r5, #1024]	@ movhi
 113:./Hardware/ESP8266/bsp_esp8266_test.c ****       strEsp8266_Fram_Record.InfBit.FramFinishFlag = 0;                           //Êé•Êî∂Ê†áÂøóÁΩÆ
 490              		.loc 1 113 7 is_stmt 1 view .LVU99
 491              		.loc 1 113 52 is_stmt 0 view .LVU100
 492 003e B5F80034 		ldrh	r3, [r5, #1024]
 493 0042 66F3CF33 		bfi	r3, r6, #15, #1
 494 0046 A5F80034 		strh	r3, [r5, #1024]	@ movhi
 114:./Hardware/ESP8266/bsp_esp8266_test.c ****       LL_USART_EnableIT_RXNE(macESP8266_USARTx);         //‰ΩøËÉΩ‰∏≤Âè£Êé•Êî∂‰∏≠Êñ≠
 495              		.loc 1 114 7 is_stmt 1 view .LVU101
 496              	.LVL38:
 497              	.LBB32:
 498              	.LBI32:
2035:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** {
 499              		.loc 2 2035 22 view .LVU102
 500              	.L18:
 501              	.LBE32:
2037:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 502              		.loc 2 2037 3 view .LVU103
 503              	.LBB38:
 504              	.LBB33:
2037:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 505              		.loc 2 2037 3 view .LVU104
2037:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 506              		.loc 2 2037 3 view .LVU105
2037:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 507              		.loc 2 2037 3 view .LVU106
 508              	.LBB34:
 509              	.LBI34:
1068:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 510              		.loc 3 1068 31 view .LVU107
 511              	.LBB35:
1070:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 512              		.loc 3 1070 5 view .LVU108
1072:Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 513              		.loc 3 1072 4 view .LVU109
 514              		.syntax unified
 515              	@ 1072 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 516 004a 54E8003F 		ldrex r3, [r4]
 517              	@ 0 "" 2
 518              	.LVL39:
1073:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 519              		.loc 3 1073 4 view .LVU110
1073:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 520              		.loc 3 1073 4 is_stmt 0 view .LVU111
 521              		.thumb
 522              		.syntax unified
 523              	.LBE35:
 524              	.LBE34:
2037:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 525              		.loc 2 2037 3 view .LVU112
 526 004e 43F02003 		orr	r3, r3, #32
ARM GAS  /tmp/ccRW1hdZ.s 			page 71


 527              	.LVL40:
2037:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 528              		.loc 2 2037 3 is_stmt 1 view .LVU113
 529              	.LBB36:
 530              	.LBI36:
1119:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 531              		.loc 3 1119 31 view .LVU114
 532              	.LBB37:
1121:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 533              		.loc 3 1121 4 view .LVU115
1123:Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 534              		.loc 3 1123 4 view .LVU116
 535              		.syntax unified
 536              	@ 1123 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 537 0052 44E80032 		strex r2, r3, [r4]
 538              	@ 0 "" 2
 539              	.LVL41:
 540              		.loc 3 1124 4 view .LVU117
 541              		.loc 3 1124 4 is_stmt 0 view .LVU118
 542              		.thumb
 543              		.syntax unified
 544              	.LBE37:
 545              	.LBE36:
2037:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 546              		.loc 2 2037 3 view .LVU119
 547 0056 002A     		cmp	r2, #0
 548 0058 F7D1     		bne	.L18
 549              	.LVL42:
 550              	.L16:
2037:Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usart.h **** }
 551              		.loc 2 2037 3 view .LVU120
 552              	.LBE33:
 553              	.LBE38:
 115:./Hardware/ESP8266/bsp_esp8266_test.c ****   }
 116:./Hardware/ESP8266/bsp_esp8266_test.c **** 
 117:./Hardware/ESP8266/bsp_esp8266_test.c ****   if ( ucTcpClosedFlag )                                             //Ê£ÄÊµãÊòØÂê¶Â§±ÂéªËøûÊé•
 554              		.loc 1 117 3 is_stmt 1 view .LVU121
 555              		.loc 1 117 8 is_stmt 0 view .LVU122
 556 005a 154B     		ldr	r3, .L28+8
 557 005c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 558              		.loc 1 117 6 view .LVU123
 559 005e 03B9     		cbnz	r3, .L26
 560              	.L15:
 118:./Hardware/ESP8266/bsp_esp8266_test.c ****   {
 119:./Hardware/ESP8266/bsp_esp8266_test.c ****     ESP8266_ExitUnvarnishSend ();                                    //ÈÄÄÂá∫ÈÄè‰º†Ê®°Âºè
 120:./Hardware/ESP8266/bsp_esp8266_test.c ****     
 121:./Hardware/ESP8266/bsp_esp8266_test.c ****     do ucStatus = ESP8266_Get_LinkStatus ();                         //Ëé∑ÂèñËøûÊé•Áä∂ÊÄÅ
 122:./Hardware/ESP8266/bsp_esp8266_test.c ****     while ( ! ucStatus );
 123:./Hardware/ESP8266/bsp_esp8266_test.c ****     
 124:./Hardware/ESP8266/bsp_esp8266_test.c ****     if ( ucStatus == 4 )                                             //Á°ÆËÆ§Â§±ÂéªËøûÊé•ÂêéÈáçËøû
 125:./Hardware/ESP8266/bsp_esp8266_test.c ****     {
 126:./Hardware/ESP8266/bsp_esp8266_test.c ****       //Ê≠£Âú®ÈáçËøûÁÉ≠ÁÇπÂíåÊúçÂä°Âô®
 127:./Hardware/ESP8266/bsp_esp8266_test.c ****       printf ( "\r\nReconnecting to hotspot and server ......\r\n" );
 128:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 129:./Hardware/ESP8266/bsp_esp8266_test.c ****       while ( ! ESP8266_JoinAP ( macUser_ESP8266_ApSsid, macUser_ESP8266_ApPwd ) );
 130:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 131:./Hardware/ESP8266/bsp_esp8266_test.c ****       while ( !	ESP8266_Link_Server ( enumTCP, macUser_ESP8266_TcpServer_IP, macUser_ESP8266_TcpSer
ARM GAS  /tmp/ccRW1hdZ.s 			page 72


 132:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 133:./Hardware/ESP8266/bsp_esp8266_test.c ****       //ÈáçËøûÁÉ≠ÁÇπÂíåÊúçÂä°Âô®ÊàêÂäü
 134:./Hardware/ESP8266/bsp_esp8266_test.c ****       printf ( "\r\nReconnect to hotspot and server successfully\r\n" );
 135:./Hardware/ESP8266/bsp_esp8266_test.c **** 
 136:./Hardware/ESP8266/bsp_esp8266_test.c ****     }
 137:./Hardware/ESP8266/bsp_esp8266_test.c ****     
 138:./Hardware/ESP8266/bsp_esp8266_test.c ****     while ( ! ESP8266_UnvarnishSend () );		
 139:./Hardware/ESP8266/bsp_esp8266_test.c ****     
 140:./Hardware/ESP8266/bsp_esp8266_test.c ****   }
 141:./Hardware/ESP8266/bsp_esp8266_test.c **** }
 561              		.loc 1 141 1 view .LVU124
 562 0060 70BD     		pop	{r4, r5, r6, pc}
 563              	.L26:
 119:./Hardware/ESP8266/bsp_esp8266_test.c ****     
 564              		.loc 1 119 5 is_stmt 1 view .LVU125
 565 0062 FFF7FEFF 		bl	ESP8266_ExitUnvarnishSend
 566              	.LVL43:
 567              	.L20:
 121:./Hardware/ESP8266/bsp_esp8266_test.c ****     while ( ! ucStatus );
 568              		.loc 1 121 5 discriminator 1 view .LVU126
 121:./Hardware/ESP8266/bsp_esp8266_test.c ****     while ( ! ucStatus );
 569              		.loc 1 121 8 discriminator 1 view .LVU127
 121:./Hardware/ESP8266/bsp_esp8266_test.c ****     while ( ! ucStatus );
 570              		.loc 1 121 19 is_stmt 0 discriminator 1 view .LVU128
 571 0066 FFF7FEFF 		bl	ESP8266_Get_LinkStatus
 572              	.LVL44:
 122:./Hardware/ESP8266/bsp_esp8266_test.c ****     
 573              		.loc 1 122 11 is_stmt 1 discriminator 1 view .LVU129
 122:./Hardware/ESP8266/bsp_esp8266_test.c ****     
 574              		.loc 1 122 5 is_stmt 0 discriminator 1 view .LVU130
 575 006a 0028     		cmp	r0, #0
 576 006c FBD0     		beq	.L20
 124:./Hardware/ESP8266/bsp_esp8266_test.c ****     {
 577              		.loc 1 124 5 is_stmt 1 view .LVU131
 124:./Hardware/ESP8266/bsp_esp8266_test.c ****     {
 578              		.loc 1 124 8 is_stmt 0 view .LVU132
 579 006e 0428     		cmp	r0, #4
 580 0070 04D0     		beq	.L27
 581              	.LVL45:
 582              	.L24:
 138:./Hardware/ESP8266/bsp_esp8266_test.c ****     
 583              		.loc 1 138 41 is_stmt 1 discriminator 1 view .LVU133
 138:./Hardware/ESP8266/bsp_esp8266_test.c ****     
 584              		.loc 1 138 11 discriminator 1 view .LVU134
 138:./Hardware/ESP8266/bsp_esp8266_test.c ****     
 585              		.loc 1 138 15 is_stmt 0 discriminator 1 view .LVU135
 586 0072 FFF7FEFF 		bl	ESP8266_UnvarnishSend
 587              	.LVL46:
 138:./Hardware/ESP8266/bsp_esp8266_test.c ****     
 588              		.loc 1 138 11 discriminator 1 view .LVU136
 589 0076 0028     		cmp	r0, #0
 590 0078 FBD0     		beq	.L24
 591 007a F1E7     		b	.L15
 592              	.LVL47:
 593              	.L27:
 127:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 594              		.loc 1 127 7 is_stmt 1 view .LVU137
ARM GAS  /tmp/ccRW1hdZ.s 			page 73


 595 007c 0D48     		ldr	r0, .L28+12
 596              	.LVL48:
 127:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 597              		.loc 1 127 7 is_stmt 0 view .LVU138
 598 007e FFF7FEFF 		bl	puts
 599              	.LVL49:
 129:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 600              		.loc 1 129 7 is_stmt 1 view .LVU139
 601              	.L22:
 129:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 602              		.loc 1 129 83 discriminator 1 view .LVU140
 129:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 603              		.loc 1 129 13 discriminator 1 view .LVU141
 129:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 604              		.loc 1 129 17 is_stmt 0 discriminator 1 view .LVU142
 605 0082 0D49     		ldr	r1, .L28+16
 606 0084 0D48     		ldr	r0, .L28+20
 607 0086 FFF7FEFF 		bl	ESP8266_JoinAP
 608              	.LVL50:
 129:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 609              		.loc 1 129 13 discriminator 1 view .LVU143
 610 008a 0028     		cmp	r0, #0
 611 008c F9D0     		beq	.L22
 612              	.L23:
 131:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 613              		.loc 1 131 125 is_stmt 1 discriminator 1 view .LVU144
 131:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 614              		.loc 1 131 13 discriminator 1 view .LVU145
 131:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 615              		.loc 1 131 17 is_stmt 0 discriminator 1 view .LVU146
 616 008e 0523     		movs	r3, #5
 617 0090 0B4A     		ldr	r2, .L28+24
 618 0092 0C49     		ldr	r1, .L28+28
 619 0094 0020     		movs	r0, #0
 620 0096 FFF7FEFF 		bl	ESP8266_Link_Server
 621              	.LVL51:
 131:./Hardware/ESP8266/bsp_esp8266_test.c ****       
 622              		.loc 1 131 13 discriminator 1 view .LVU147
 623 009a 0028     		cmp	r0, #0
 624 009c F7D0     		beq	.L23
 134:./Hardware/ESP8266/bsp_esp8266_test.c **** 
 625              		.loc 1 134 7 is_stmt 1 view .LVU148
 626 009e 0A48     		ldr	r0, .L28+32
 627 00a0 FFF7FEFF 		bl	puts
 628              	.LVL52:
 629 00a4 E5E7     		b	.L24
 630              	.L29:
 631 00a6 00BF     		.align	2
 632              	.L28:
 633 00a8 00000000 		.word	strEsp8266_Fram_Record
 634 00ac 0C440040 		.word	1073759244
 635 00b0 00000000 		.word	.LANCHOR0
 636 00b4 00000000 		.word	.LC22
 637 00b8 7C000000 		.word	.LC13
 638 00bc 88000000 		.word	.LC14
 639 00c0 D0000000 		.word	.LC17
 640 00c4 D4000000 		.word	.LC18
ARM GAS  /tmp/ccRW1hdZ.s 			page 74


 641 00c8 30000000 		.word	.LC23
 642              		.cfi_endproc
 643              	.LFE741:
 645              		.global	ucTcpClosedFlag
 646              		.section	.bss.ucTcpClosedFlag,"aw",%nobits
 647              		.set	.LANCHOR0,. + 0
 650              	ucTcpClosedFlag:
 651 0000 00       		.space	1
 652              		.text
 653              	.Letext0:
 654              		.file 4 "/home/hao/Documents/gcc-arm-none-eabi/arm-none-eabi/include/machine/_default_types.h"
 655              		.file 5 "/home/hao/Documents/gcc-arm-none-eabi/arm-none-eabi/include/sys/_stdint.h"
 656              		.file 6 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f429xx.h"
 657              		.file 7 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f4xx.h"
 658              		.file 8 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_gpio.h"
 659              		.file 9 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_rcc.h"
 660              		.file 10 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_dma.h"
 661              		.file 11 "./Hardware/ESP8266/esp8266.h"
 662              		.file 12 "./Hardware/ESP8266/bsp_esp8266_test.h"
 663              		.file 13 "/home/hao/Documents/gcc-arm-none-eabi/arm-none-eabi/include/string.h"
 664              		.file 14 "/home/hao/Documents/gcc-arm-none-eabi/arm-none-eabi/include/stdio.h"
 665              		.file 15 "<built-in>"
ARM GAS  /tmp/ccRW1hdZ.s 			page 75


DEFINED SYMBOLS
                            *ABS*:0000000000000000 bsp_esp8266_test.c
     /tmp/ccRW1hdZ.s:18     .rodata.analytical_data.str1.4:0000000000000000 $d
     /tmp/ccRW1hdZ.s:46     .text.analytical_data:0000000000000000 $t
     /tmp/ccRW1hdZ.s:54     .text.analytical_data:0000000000000000 analytical_data
     /tmp/ccRW1hdZ.s:165    .text.analytical_data:0000000000000080 $d
     /tmp/ccRW1hdZ.s:179    .rodata.ESP8266_StaTcpClient_Unvarnish_ConfigTest.str1.4:0000000000000000 $d
     /tmp/ccRW1hdZ.s:230    .text.ESP8266_StaTcpClient_Unvarnish_ConfigTest:0000000000000000 $t
     /tmp/ccRW1hdZ.s:237    .text.ESP8266_StaTcpClient_Unvarnish_ConfigTest:0000000000000000 ESP8266_StaTcpClient_Unvarnish_ConfigTest
     /tmp/ccRW1hdZ.s:363    .text.ESP8266_StaTcpClient_Unvarnish_ConfigTest:0000000000000084 $d
     /tmp/ccRW1hdZ.s:381    .rodata.ESP8266_CheckRecvDataTest.str1.4:0000000000000000 $d
     /tmp/ccRW1hdZ.s:390    .text.ESP8266_CheckRecvDataTest:0000000000000000 $t
     /tmp/ccRW1hdZ.s:397    .text.ESP8266_CheckRecvDataTest:0000000000000000 ESP8266_CheckRecvDataTest
     /tmp/ccRW1hdZ.s:633    .text.ESP8266_CheckRecvDataTest:00000000000000a8 $d
     /tmp/ccRW1hdZ.s:650    .bss.ucTcpClosedFlag:0000000000000000 ucTcpClosedFlag
     /tmp/ccRW1hdZ.s:651    .bss.ucTcpClosedFlag:0000000000000000 $d

UNDEFINED SYMBOLS
strstr
sscanf
printf
strEsp8266_Fram_Record
puts
HAL_GPIO_WritePin
ESP8266_AT_Test
ESP8266_Net_Mode_Choose
ESP8266_JoinAP
ESP8266_Enable_MultipleId
ESP8266_Link_Server
ESP8266_UnvarnishSend
ESP8266_ExitUnvarnishSend
ESP8266_Get_LinkStatus
